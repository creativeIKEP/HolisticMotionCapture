// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mediapipe/modules/objectron/calculators/belief_decoder_config.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mediapipe {

  /// <summary>Holder for reflection information generated from mediapipe/modules/objectron/calculators/belief_decoder_config.proto</summary>
  public static partial class BeliefDecoderConfigReflection {

    #region Descriptor
    /// <summary>File descriptor for mediapipe/modules/objectron/calculators/belief_decoder_config.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static BeliefDecoderConfigReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CkNtZWRpYXBpcGUvbW9kdWxlcy9vYmplY3Ryb24vY2FsY3VsYXRvcnMvYmVs",
            "aWVmX2RlY29kZXJfY29uZmlnLnByb3RvEgltZWRpYXBpcGUixAEKE0JlbGll",
            "ZkRlY29kZXJDb25maWcSHgoRaGVhdG1hcF90aHJlc2hvbGQYASABKAI6AzAu",
            "ORIeChJsb2NhbF9tYXhfZGlzdGFuY2UYAiABKAI6AjEwEiIKEW9mZnNldF9z",
            "Y2FsZV9jb2VmGAMgASgCOgMwLjVCAhgBEhUKDXZvdGluZ19yYWRpdXMYBCAB",
            "KAUSGAoQdm90aW5nX2FsbG93YW5jZRgFIAEoBRIYChB2b3RpbmdfdGhyZXNo",
            "b2xkGAYgASgC"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.BeliefDecoderConfig), global::Mediapipe.BeliefDecoderConfig.Parser, new[]{ "HeatmapThreshold", "LocalMaxDistance", "OffsetScaleCoef", "VotingRadius", "VotingAllowance", "VotingThreshold" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class BeliefDecoderConfig : pb::IMessage<BeliefDecoderConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BeliefDecoderConfig> _parser = new pb::MessageParser<BeliefDecoderConfig>(() => new BeliefDecoderConfig());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<BeliefDecoderConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.BeliefDecoderConfigReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BeliefDecoderConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BeliefDecoderConfig(BeliefDecoderConfig other) : this() {
      _hasBits0 = other._hasBits0;
      heatmapThreshold_ = other.heatmapThreshold_;
      localMaxDistance_ = other.localMaxDistance_;
      offsetScaleCoef_ = other.offsetScaleCoef_;
      votingRadius_ = other.votingRadius_;
      votingAllowance_ = other.votingAllowance_;
      votingThreshold_ = other.votingThreshold_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BeliefDecoderConfig Clone() {
      return new BeliefDecoderConfig(this);
    }

    /// <summary>Field number for the "heatmap_threshold" field.</summary>
    public const int HeatmapThresholdFieldNumber = 1;
    private readonly static float HeatmapThresholdDefaultValue = 0.9F;

    private float heatmapThreshold_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float HeatmapThreshold {
      get { if ((_hasBits0 & 1) != 0) { return heatmapThreshold_; } else { return HeatmapThresholdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        heatmapThreshold_ = value;
      }
    }
    /// <summary>Gets whether the "heatmap_threshold" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHeatmapThreshold {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "heatmap_threshold" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHeatmapThreshold() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "local_max_distance" field.</summary>
    public const int LocalMaxDistanceFieldNumber = 2;
    private readonly static float LocalMaxDistanceDefaultValue = 10F;

    private float localMaxDistance_;
    /// <summary>
    /// Maximum distance in pixels between two local max heatmap values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float LocalMaxDistance {
      get { if ((_hasBits0 & 2) != 0) { return localMaxDistance_; } else { return LocalMaxDistanceDefaultValue; } }
      set {
        _hasBits0 |= 2;
        localMaxDistance_ = value;
      }
    }
    /// <summary>Gets whether the "local_max_distance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLocalMaxDistance {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "local_max_distance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLocalMaxDistance() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "offset_scale_coef" field.</summary>
    public const int OffsetScaleCoefFieldNumber = 3;
    private readonly static float OffsetScaleCoefDefaultValue = 0.5F;

    private float offsetScaleCoef_;
    /// <summary>
    /// Coefficient of offset_scale.
    /// offset_scale = offset_scale_coef * min(rows, cols).
    /// offset_scale is used to multiply the offset predictions from the network.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float OffsetScaleCoef {
      get { if ((_hasBits0 & 4) != 0) { return offsetScaleCoef_; } else { return OffsetScaleCoefDefaultValue; } }
      set {
        _hasBits0 |= 4;
        offsetScaleCoef_ = value;
      }
    }
    /// <summary>Gets whether the "offset_scale_coef" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOffsetScaleCoef {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "offset_scale_coef" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOffsetScaleCoef() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "voting_radius" field.</summary>
    public const int VotingRadiusFieldNumber = 4;
    private readonly static int VotingRadiusDefaultValue = 0;

    private int votingRadius_;
    /// <summary>
    /// The radius for vertex voting. Use no voting if the radius is less than or
    /// euqal to 1. Example: 10.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int VotingRadius {
      get { if ((_hasBits0 & 8) != 0) { return votingRadius_; } else { return VotingRadiusDefaultValue; } }
      set {
        _hasBits0 |= 8;
        votingRadius_ = value;
      }
    }
    /// <summary>Gets whether the "voting_radius" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVotingRadius {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "voting_radius" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVotingRadius() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "voting_allowance" field.</summary>
    public const int VotingAllowanceFieldNumber = 5;
    private readonly static int VotingAllowanceDefaultValue = 0;

    private int votingAllowance_;
    /// <summary>
    /// The number of pixels to determine whether two points are the same.
    /// Example: 5 (voting_radius / 2).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int VotingAllowance {
      get { if ((_hasBits0 & 16) != 0) { return votingAllowance_; } else { return VotingAllowanceDefaultValue; } }
      set {
        _hasBits0 |= 16;
        votingAllowance_ = value;
      }
    }
    /// <summary>Gets whether the "voting_allowance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVotingAllowance {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "voting_allowance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVotingAllowance() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "voting_threshold" field.</summary>
    public const int VotingThresholdFieldNumber = 6;
    private readonly static float VotingThresholdDefaultValue = 0F;

    private float votingThreshold_;
    /// <summary>
    /// The threshold of beliefs, with which the points can vote. Example: 0.2.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float VotingThreshold {
      get { if ((_hasBits0 & 32) != 0) { return votingThreshold_; } else { return VotingThresholdDefaultValue; } }
      set {
        _hasBits0 |= 32;
        votingThreshold_ = value;
      }
    }
    /// <summary>Gets whether the "voting_threshold" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVotingThreshold {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "voting_threshold" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVotingThreshold() {
      _hasBits0 &= ~32;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as BeliefDecoderConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(BeliefDecoderConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(HeatmapThreshold, other.HeatmapThreshold)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LocalMaxDistance, other.LocalMaxDistance)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OffsetScaleCoef, other.OffsetScaleCoef)) return false;
      if (VotingRadius != other.VotingRadius) return false;
      if (VotingAllowance != other.VotingAllowance) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(VotingThreshold, other.VotingThreshold)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasHeatmapThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(HeatmapThreshold);
      if (HasLocalMaxDistance) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LocalMaxDistance);
      if (HasOffsetScaleCoef) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OffsetScaleCoef);
      if (HasVotingRadius) hash ^= VotingRadius.GetHashCode();
      if (HasVotingAllowance) hash ^= VotingAllowance.GetHashCode();
      if (HasVotingThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(VotingThreshold);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasHeatmapThreshold) {
        output.WriteRawTag(13);
        output.WriteFloat(HeatmapThreshold);
      }
      if (HasLocalMaxDistance) {
        output.WriteRawTag(21);
        output.WriteFloat(LocalMaxDistance);
      }
      if (HasOffsetScaleCoef) {
        output.WriteRawTag(29);
        output.WriteFloat(OffsetScaleCoef);
      }
      if (HasVotingRadius) {
        output.WriteRawTag(32);
        output.WriteInt32(VotingRadius);
      }
      if (HasVotingAllowance) {
        output.WriteRawTag(40);
        output.WriteInt32(VotingAllowance);
      }
      if (HasVotingThreshold) {
        output.WriteRawTag(53);
        output.WriteFloat(VotingThreshold);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasHeatmapThreshold) {
        output.WriteRawTag(13);
        output.WriteFloat(HeatmapThreshold);
      }
      if (HasLocalMaxDistance) {
        output.WriteRawTag(21);
        output.WriteFloat(LocalMaxDistance);
      }
      if (HasOffsetScaleCoef) {
        output.WriteRawTag(29);
        output.WriteFloat(OffsetScaleCoef);
      }
      if (HasVotingRadius) {
        output.WriteRawTag(32);
        output.WriteInt32(VotingRadius);
      }
      if (HasVotingAllowance) {
        output.WriteRawTag(40);
        output.WriteInt32(VotingAllowance);
      }
      if (HasVotingThreshold) {
        output.WriteRawTag(53);
        output.WriteFloat(VotingThreshold);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasHeatmapThreshold) {
        size += 1 + 4;
      }
      if (HasLocalMaxDistance) {
        size += 1 + 4;
      }
      if (HasOffsetScaleCoef) {
        size += 1 + 4;
      }
      if (HasVotingRadius) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(VotingRadius);
      }
      if (HasVotingAllowance) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(VotingAllowance);
      }
      if (HasVotingThreshold) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(BeliefDecoderConfig other) {
      if (other == null) {
        return;
      }
      if (other.HasHeatmapThreshold) {
        HeatmapThreshold = other.HeatmapThreshold;
      }
      if (other.HasLocalMaxDistance) {
        LocalMaxDistance = other.LocalMaxDistance;
      }
      if (other.HasOffsetScaleCoef) {
        OffsetScaleCoef = other.OffsetScaleCoef;
      }
      if (other.HasVotingRadius) {
        VotingRadius = other.VotingRadius;
      }
      if (other.HasVotingAllowance) {
        VotingAllowance = other.VotingAllowance;
      }
      if (other.HasVotingThreshold) {
        VotingThreshold = other.VotingThreshold;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            HeatmapThreshold = input.ReadFloat();
            break;
          }
          case 21: {
            LocalMaxDistance = input.ReadFloat();
            break;
          }
          case 29: {
            OffsetScaleCoef = input.ReadFloat();
            break;
          }
          case 32: {
            VotingRadius = input.ReadInt32();
            break;
          }
          case 40: {
            VotingAllowance = input.ReadInt32();
            break;
          }
          case 53: {
            VotingThreshold = input.ReadFloat();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            HeatmapThreshold = input.ReadFloat();
            break;
          }
          case 21: {
            LocalMaxDistance = input.ReadFloat();
            break;
          }
          case 29: {
            OffsetScaleCoef = input.ReadFloat();
            break;
          }
          case 32: {
            VotingRadius = input.ReadInt32();
            break;
          }
          case 40: {
            VotingAllowance = input.ReadInt32();
            break;
          }
          case 53: {
            VotingThreshold = input.ReadFloat();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
