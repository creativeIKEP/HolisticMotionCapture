// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mediapipe/modules/objectron/calculators/a_r_capture_metadata.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mediapipe {

  /// <summary>Holder for reflection information generated from mediapipe/modules/objectron/calculators/a_r_capture_metadata.proto</summary>
  public static partial class ARCaptureMetadataReflection {

    #region Descriptor
    /// <summary>File descriptor for mediapipe/modules/objectron/calculators/a_r_capture_metadata.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ARCaptureMetadataReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CkJtZWRpYXBpcGUvbW9kdWxlcy9vYmplY3Ryb24vY2FsY3VsYXRvcnMvYV9y",
            "X2NhcHR1cmVfbWV0YWRhdGEucHJvdG8SCW1lZGlhcGlwZSL0AgoXQVZDYW1l",
            "cmFDYWxpYnJhdGlvbkRhdGESHAoQaW50cmluc2ljX21hdHJpeBgBIAMoAkIC",
            "EAESMgoqaW50cmluc2ljX21hdHJpeF9yZWZlcmVuY2VfZGltZW5zaW9uX3dp",
            "ZHRoGAIgASgCEjMKK2ludHJpbnNpY19tYXRyaXhfcmVmZXJlbmNlX2RpbWVu",
            "c2lvbl9oZWlnaHQYAyABKAISHAoQZXh0cmluc2ljX21hdHJpeBgEIAMoAkIC",
            "EAESEgoKcGl4ZWxfc2l6ZRgFIAEoAhIpCh1sZW5zX2Rpc3RvcnRpb25fbG9v",
            "a3VwX3ZhbHVlcxgGIAMoAkICEAESMQolaW52ZXJzZV9sZW5zX2Rpc3RvcnRp",
            "b25fbG9va3VwX3ZhbHVlcxgHIAMoAkICEAESIAoYbGVuc19kaXN0b3J0aW9u",
            "X2NlbnRlcl94GAggASgCEiAKGGxlbnNfZGlzdG9ydGlvbl9jZW50ZXJfeRgJ",
            "IAEoAiLXBAoLQVZEZXB0aERhdGESFgoOZGVwdGhfZGF0YV9tYXAYASABKAwS",
            "FwoPZGVwdGhfZGF0YV90eXBlGAIgASgJEkYKE2RlcHRoX2RhdGFfYWNjdXJh",
            "Y3kYAyABKA4yHy5tZWRpYXBpcGUuQVZEZXB0aERhdGEuQWNjdXJhY3k6CFJF",
            "TEFUSVZFEhsKE2RlcHRoX2RhdGFfZmlsdGVyZWQYBCABKAgSOgoSZGVwdGhf",
            "ZGF0YV9xdWFsaXR5GAUgASgOMh4ubWVkaWFwaXBlLkFWRGVwdGhEYXRhLlF1",
            "YWxpdHkSQwoXY2FtZXJhX2NhbGlicmF0aW9uX2RhdGEYBiABKAsyIi5tZWRp",
            "YXBpcGUuQVZDYW1lcmFDYWxpYnJhdGlvbkRhdGESLQolZGVwdGhfZGF0YV9t",
            "YXBfb3JpZ2luYWxfbWluaW11bV92YWx1ZRgHIAEoAhItCiVkZXB0aF9kYXRh",
            "X21hcF9vcmlnaW5hbF9tYXhpbXVtX3ZhbHVlGAggASgCEhwKFGRlcHRoX2Rh",
            "dGFfbWFwX3dpZHRoGAkgASgFEh0KFWRlcHRoX2RhdGFfbWFwX2hlaWdodBgK",
            "IAEoBRIhChlkZXB0aF9kYXRhX21hcF9yYXdfdmFsdWVzGAsgASgMIj4KCEFj",
            "Y3VyYWN5EhYKElVOREVGSU5FRF9BQ0NVUkFDWRAAEgwKCFJFTEFUSVZFEAES",
            "DAoIQUJTT0xVVEUQAiIzCgdRdWFsaXR5EhUKEVVOREVGSU5FRF9RVUFMSVRZ",
            "EAASCAoESElHSBABEgcKA0xPVxACIp8CCg9BUkxpZ2h0RXN0aW1hdGUSGQoR",
            "YW1iaWVudF9pbnRlbnNpdHkYASABKAESIQoZYW1iaWVudF9jb2xvcl90ZW1w",
            "ZXJhdHVyZRgCIAEoARIsCiBzcGhlcmljYWxfaGFybW9uaWNzX2NvZWZmaWNp",
            "ZW50cxgDIAMoAkICEAESSwoXcHJpbWFyeV9saWdodF9kaXJlY3Rpb24YBCAB",
            "KAsyKi5tZWRpYXBpcGUuQVJMaWdodEVzdGltYXRlLkRpcmVjdGlvblZlY3Rv",
            "chIfChdwcmltYXJ5X2xpZ2h0X2ludGVuc2l0eRgFIAEoAhoyCg9EaXJlY3Rp",
            "b25WZWN0b3ISCQoBeBgBIAEoAhIJCgF5GAIgASgCEgkKAXoYAyABKAIirQUK",
            "CEFSQ2FtZXJhEkYKDnRyYWNraW5nX3N0YXRlGAEgASgOMiEubWVkaWFwaXBl",
            "LkFSQ2FtZXJhLlRyYWNraW5nU3RhdGU6C1VOQVZBSUxBQkxFEkwKFXRyYWNr",
            "aW5nX3N0YXRlX3JlYXNvbhgCIAEoDjInLm1lZGlhcGlwZS5BUkNhbWVyYS5U",
            "cmFja2luZ1N0YXRlUmVhc29uOgROT05FEhUKCXRyYW5zZm9ybRgDIAMoAkIC",
            "EAESNQoMZXVsZXJfYW5nbGVzGAQgASgLMh8ubWVkaWFwaXBlLkFSQ2FtZXJh",
            "LkV1bGVyQW5nbGVzEh4KFmltYWdlX3Jlc29sdXRpb25fd2lkdGgYBSABKAUS",
            "HwoXaW1hZ2VfcmVzb2x1dGlvbl9oZWlnaHQYBiABKAUSFgoKaW50cmluc2lj",
            "cxgHIAMoAkICEAESHQoRcHJvamVjdGlvbl9tYXRyaXgYCCADKAJCAhABEhcK",
            "C3ZpZXdfbWF0cml4GAkgAygCQgIQARo3CgtFdWxlckFuZ2xlcxIMCgRyb2xs",
            "GAEgASgCEg0KBXBpdGNoGAIgASgCEgsKA3lhdxgDIAEoAiJXCg1UcmFja2lu",
            "Z1N0YXRlEhwKGFVOREVGSU5FRF9UUkFDS0lOR19TVEFURRAAEg8KC1VOQVZB",
            "SUxBQkxFEAESCwoHTElNSVRFRBACEgoKBk5PUk1BTBADIpkBChNUcmFja2lu",
            "Z1N0YXRlUmVhc29uEiMKH1VOREVGSU5FRF9UUkFDS0lOR19TVEFURV9SRUFT",
            "T04QABIICgROT05FEAESEAoMSU5JVElBTElaSU5HEAISFAoQRVhDRVNTSVZF",
            "X01PVElPThADEhkKFUlOU1VGRklDSUVOVF9GRUFUVVJFUxAEEhAKDFJFTE9D",
            "QUxJWklORxAFItICCg5BUkZhY2VHZW9tZXRyeRIyCgh2ZXJ0aWNlcxgBIAMo",
            "CzIgLm1lZGlhcGlwZS5BUkZhY2VHZW9tZXRyeS5WZXJ0ZXgSFAoMdmVydGV4",
            "X2NvdW50GAIgASgFEkgKE3RleHR1cmVfY29vcmRpbmF0ZXMYAyADKAsyKy5t",
            "ZWRpYXBpcGUuQVJGYWNlR2VvbWV0cnkuVGV4dHVyZUNvb3JkaW5hdGUSIAoY",
            "dGV4dHVyZV9jb29yZGluYXRlX2NvdW50GAQgASgFEhwKEHRyaWFuZ2xlX2lu",
            "ZGljZXMYBSADKAVCAhABEhYKDnRyaWFuZ2xlX2NvdW50GAYgASgFGikKBlZl",
            "cnRleBIJCgF4GAEgASgCEgkKAXkYAiABKAISCQoBehgDIAEoAhopChFUZXh0",
            "dXJlQ29vcmRpbmF0ZRIJCgF1GAEgASgCEgkKAXYYAiABKAIikgEKD0FSQmxl",
            "bmRTaGFwZU1hcBI0CgdlbnRyaWVzGAEgAygLMiMubWVkaWFwaXBlLkFSQmxl",
            "bmRTaGFwZU1hcC5NYXBFbnRyeRpJCghNYXBFbnRyeRIcChRibGVuZF9zaGFw",
            "ZV9sb2NhdGlvbhgBIAEoCRIfChdibGVuZF9zaGFwZV9jb2VmZmljaWVudBgC",
            "IAEoAiKUAQoMQVJGYWNlQW5jaG9yEisKCGdlb21ldHJ5GAEgASgLMhkubWVk",
            "aWFwaXBlLkFSRmFjZUdlb21ldHJ5EjAKDGJsZW5kX3NoYXBlcxgCIAEoCzIa",
            "Lm1lZGlhcGlwZS5BUkJsZW5kU2hhcGVNYXASEQoJdHJhbnNmb3JtGAMgAygC",
            "EhIKCmlzX3RyYWNrZWQYBCABKAgisgMKD0FSUGxhbmVHZW9tZXRyeRIzCgh2",
            "ZXJ0aWNlcxgBIAMoCzIhLm1lZGlhcGlwZS5BUlBsYW5lR2VvbWV0cnkuVmVy",
            "dGV4EhQKDHZlcnRleF9jb3VudBgCIAEoBRJJChN0ZXh0dXJlX2Nvb3JkaW5h",
            "dGVzGAMgAygLMiwubWVkaWFwaXBlLkFSUGxhbmVHZW9tZXRyeS5UZXh0dXJl",
            "Q29vcmRpbmF0ZRIgChh0ZXh0dXJlX2Nvb3JkaW5hdGVfY291bnQYBCABKAUS",
            "HAoQdHJpYW5nbGVfaW5kaWNlcxgFIAMoBUICEAESFgoOdHJpYW5nbGVfY291",
            "bnQYBiABKAUSPAoRYm91bmRhcnlfdmVydGljZXMYByADKAsyIS5tZWRpYXBp",
            "cGUuQVJQbGFuZUdlb21ldHJ5LlZlcnRleBIdChVib3VuZGFyeV92ZXJ0ZXhf",
            "Y291bnQYCCABKAUaKQoGVmVydGV4EgkKAXgYASABKAISCQoBeRgCIAEoAhIJ",
            "CgF6GAMgASgCGikKEVRleHR1cmVDb29yZGluYXRlEgkKAXUYASABKAISCQoB",
            "dhgCIAEoAiLcBQoNQVJQbGFuZUFuY2hvchISCgppZGVudGlmaWVyGAEgASgJ",
            "EhEKCXRyYW5zZm9ybRgCIAMoAhI1CglhbGlnbm1lbnQYAyABKA4yIi5tZWRp",
            "YXBpcGUuQVJQbGFuZUFuY2hvci5BbGlnbm1lbnQSLAoIZ2VvbWV0cnkYBCAB",
            "KAsyGi5tZWRpYXBpcGUuQVJQbGFuZUdlb21ldHJ5EjQKBmNlbnRlchgFIAEo",
            "CzIkLm1lZGlhcGlwZS5BUlBsYW5lQW5jaG9yLlBsYW5lVmVjdG9yEjQKBmV4",
            "dGVudBgGIAEoCzIkLm1lZGlhcGlwZS5BUlBsYW5lQW5jaG9yLlBsYW5lVmVj",
            "dG9yEiAKGGNsYXNzaWZpY2F0aW9uX3N1cHBvcnRlZBgHIAEoCBJECg5jbGFz",
            "c2lmaWNhdGlvbhgIIAEoDjIsLm1lZGlhcGlwZS5BUlBsYW5lQW5jaG9yLlBs",
            "YW5lQ2xhc3NpZmljYXRpb24SUQoVY2xhc3NpZmljYXRpb25fc3RhdHVzGAkg",
            "ASgOMjIubWVkaWFwaXBlLkFSUGxhbmVBbmNob3IuUGxhbmVDbGFzc2lmaWNh",
            "dGlvblN0YXR1cxouCgtQbGFuZVZlY3RvchIJCgF4GAEgASgCEgkKAXkYAiAB",
            "KAISCQoBehgDIAEoAiI4CglBbGlnbm1lbnQSDQoJVU5ERUZJTkVEEAASDgoK",
            "SE9SSVpPTlRBTBABEgwKCFZFUlRJQ0FMEAIiVgoTUGxhbmVDbGFzc2lmaWNh",
            "dGlvbhIICgROT05FEAASCAoEV0FMTBABEgkKBUZMT09SEAISCwoHQ0VJTElO",
            "RxADEgkKBVRBQkxFEAQSCAoEU0VBVBAFIlYKGVBsYW5lQ2xhc3NpZmljYXRp",
            "b25TdGF0dXMSCwoHVU5LTk9XThAAEg8KC1VOQVZBSUxBQkxFEAESEAoMVU5E",
            "RVRFUk1JTkVEEAISCQoFS05PV04QAyKNAQoMQVJQb2ludENsb3VkEg0KBWNv",
            "dW50GAEgASgFEiwKBXBvaW50GAIgAygLMh0ubWVkaWFwaXBlLkFSUG9pbnRD",
            "bG91ZC5Qb2ludBIWCgppZGVudGlmaWVyGAMgAygDQgIQARooCgVQb2ludBIJ",
            "CgF4GAEgASgCEgkKAXkYAiABKAISCQoBehgDIAEoAiLSAgoHQVJGcmFtZRIR",
            "Cgl0aW1lc3RhbXAYASABKAESKgoKZGVwdGhfZGF0YRgCIAEoCzIWLm1lZGlh",
            "cGlwZS5BVkRlcHRoRGF0YRIcChRkZXB0aF9kYXRhX3RpbWVzdGFtcBgDIAEo",
            "ARIjCgZjYW1lcmEYBCABKAsyEy5tZWRpYXBpcGUuQVJDYW1lcmESMgoObGln",
            "aHRfZXN0aW1hdGUYBSABKAsyGi5tZWRpYXBpcGUuQVJMaWdodEVzdGltYXRl",
            "EiwKC2ZhY2VfYW5jaG9yGAYgASgLMhcubWVkaWFwaXBlLkFSRmFjZUFuY2hv",
            "chIuCgxwbGFuZV9hbmNob3IYByADKAsyGC5tZWRpYXBpcGUuQVJQbGFuZUFu",
            "Y2hvchIzChJyYXdfZmVhdHVyZV9wb2ludHMYCCABKAsyFy5tZWRpYXBpcGUu",
            "QVJQb2ludENsb3Vk"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.AVCameraCalibrationData), global::Mediapipe.AVCameraCalibrationData.Parser, new[]{ "IntrinsicMatrix", "IntrinsicMatrixReferenceDimensionWidth", "IntrinsicMatrixReferenceDimensionHeight", "ExtrinsicMatrix", "PixelSize", "LensDistortionLookupValues", "InverseLensDistortionLookupValues", "LensDistortionCenterX", "LensDistortionCenterY" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.AVDepthData), global::Mediapipe.AVDepthData.Parser, new[]{ "DepthDataMap", "DepthDataType", "DepthDataAccuracy", "DepthDataFiltered", "DepthDataQuality", "CameraCalibrationData", "DepthDataMapOriginalMinimumValue", "DepthDataMapOriginalMaximumValue", "DepthDataMapWidth", "DepthDataMapHeight", "DepthDataMapRawValues" }, null, new[]{ typeof(global::Mediapipe.AVDepthData.Types.Accuracy), typeof(global::Mediapipe.AVDepthData.Types.Quality) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARLightEstimate), global::Mediapipe.ARLightEstimate.Parser, new[]{ "AmbientIntensity", "AmbientColorTemperature", "SphericalHarmonicsCoefficients", "PrimaryLightDirection", "PrimaryLightIntensity" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARLightEstimate.Types.DirectionVector), global::Mediapipe.ARLightEstimate.Types.DirectionVector.Parser, new[]{ "X", "Y", "Z" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARCamera), global::Mediapipe.ARCamera.Parser, new[]{ "TrackingState", "TrackingStateReason", "Transform", "EulerAngles", "ImageResolutionWidth", "ImageResolutionHeight", "Intrinsics", "ProjectionMatrix", "ViewMatrix" }, null, new[]{ typeof(global::Mediapipe.ARCamera.Types.TrackingState), typeof(global::Mediapipe.ARCamera.Types.TrackingStateReason) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARCamera.Types.EulerAngles), global::Mediapipe.ARCamera.Types.EulerAngles.Parser, new[]{ "Roll", "Pitch", "Yaw" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARFaceGeometry), global::Mediapipe.ARFaceGeometry.Parser, new[]{ "Vertices", "VertexCount", "TextureCoordinates", "TextureCoordinateCount", "TriangleIndices", "TriangleCount" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARFaceGeometry.Types.Vertex), global::Mediapipe.ARFaceGeometry.Types.Vertex.Parser, new[]{ "X", "Y", "Z" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARFaceGeometry.Types.TextureCoordinate), global::Mediapipe.ARFaceGeometry.Types.TextureCoordinate.Parser, new[]{ "U", "V" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARBlendShapeMap), global::Mediapipe.ARBlendShapeMap.Parser, new[]{ "Entries" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARBlendShapeMap.Types.MapEntry), global::Mediapipe.ARBlendShapeMap.Types.MapEntry.Parser, new[]{ "BlendShapeLocation", "BlendShapeCoefficient" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARFaceAnchor), global::Mediapipe.ARFaceAnchor.Parser, new[]{ "Geometry", "BlendShapes", "Transform", "IsTracked" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARPlaneGeometry), global::Mediapipe.ARPlaneGeometry.Parser, new[]{ "Vertices", "VertexCount", "TextureCoordinates", "TextureCoordinateCount", "TriangleIndices", "TriangleCount", "BoundaryVertices", "BoundaryVertexCount" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARPlaneGeometry.Types.Vertex), global::Mediapipe.ARPlaneGeometry.Types.Vertex.Parser, new[]{ "X", "Y", "Z" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARPlaneGeometry.Types.TextureCoordinate), global::Mediapipe.ARPlaneGeometry.Types.TextureCoordinate.Parser, new[]{ "U", "V" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARPlaneAnchor), global::Mediapipe.ARPlaneAnchor.Parser, new[]{ "Identifier", "Transform", "Alignment", "Geometry", "Center", "Extent", "ClassificationSupported", "Classification", "ClassificationStatus" }, null, new[]{ typeof(global::Mediapipe.ARPlaneAnchor.Types.Alignment), typeof(global::Mediapipe.ARPlaneAnchor.Types.PlaneClassification), typeof(global::Mediapipe.ARPlaneAnchor.Types.PlaneClassificationStatus) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARPlaneAnchor.Types.PlaneVector), global::Mediapipe.ARPlaneAnchor.Types.PlaneVector.Parser, new[]{ "X", "Y", "Z" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARPointCloud), global::Mediapipe.ARPointCloud.Parser, new[]{ "Count", "Point", "Identifier" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARPointCloud.Types.Point), global::Mediapipe.ARPointCloud.Types.Point.Parser, new[]{ "X", "Y", "Z" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ARFrame), global::Mediapipe.ARFrame.Parser, new[]{ "Timestamp", "DepthData", "DepthDataTimestamp", "Camera", "LightEstimate", "FaceAnchor", "PlaneAnchor", "RawFeaturePoints" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Info about the camera characteristics used to capture images and depth data.
  /// See developer.apple.com/documentation/avfoundation/avcameracalibrationdata
  /// for more information.
  /// </summary>
  public sealed partial class AVCameraCalibrationData : pb::IMessage<AVCameraCalibrationData>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AVCameraCalibrationData> _parser = new pb::MessageParser<AVCameraCalibrationData>(() => new AVCameraCalibrationData());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AVCameraCalibrationData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.ARCaptureMetadataReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AVCameraCalibrationData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AVCameraCalibrationData(AVCameraCalibrationData other) : this() {
      _hasBits0 = other._hasBits0;
      intrinsicMatrix_ = other.intrinsicMatrix_.Clone();
      intrinsicMatrixReferenceDimensionWidth_ = other.intrinsicMatrixReferenceDimensionWidth_;
      intrinsicMatrixReferenceDimensionHeight_ = other.intrinsicMatrixReferenceDimensionHeight_;
      extrinsicMatrix_ = other.extrinsicMatrix_.Clone();
      pixelSize_ = other.pixelSize_;
      lensDistortionLookupValues_ = other.lensDistortionLookupValues_.Clone();
      inverseLensDistortionLookupValues_ = other.inverseLensDistortionLookupValues_.Clone();
      lensDistortionCenterX_ = other.lensDistortionCenterX_;
      lensDistortionCenterY_ = other.lensDistortionCenterY_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AVCameraCalibrationData Clone() {
      return new AVCameraCalibrationData(this);
    }

    /// <summary>Field number for the "intrinsic_matrix" field.</summary>
    public const int IntrinsicMatrixFieldNumber = 1;
    private static readonly pb::FieldCodec<float> _repeated_intrinsicMatrix_codec
        = pb::FieldCodec.ForFloat(10);
    private readonly pbc::RepeatedField<float> intrinsicMatrix_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// 3x3 row-major matrix relating a camera's internal properties to an ideal
    /// pinhole-camera model.
    /// See
    /// developer.apple.com/documentation/avfoundation/avcameracalibrationdata/2881135-intrinsicmatrix
    /// for detailed usage information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<float> IntrinsicMatrix {
      get { return intrinsicMatrix_; }
    }

    /// <summary>Field number for the "intrinsic_matrix_reference_dimension_width" field.</summary>
    public const int IntrinsicMatrixReferenceDimensionWidthFieldNumber = 2;
    private readonly static float IntrinsicMatrixReferenceDimensionWidthDefaultValue = 0F;

    private float intrinsicMatrixReferenceDimensionWidth_;
    /// <summary>
    /// The image dimensions to which the intrinsic_matrix values are relative.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float IntrinsicMatrixReferenceDimensionWidth {
      get { if ((_hasBits0 & 1) != 0) { return intrinsicMatrixReferenceDimensionWidth_; } else { return IntrinsicMatrixReferenceDimensionWidthDefaultValue; } }
      set {
        _hasBits0 |= 1;
        intrinsicMatrixReferenceDimensionWidth_ = value;
      }
    }
    /// <summary>Gets whether the "intrinsic_matrix_reference_dimension_width" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIntrinsicMatrixReferenceDimensionWidth {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "intrinsic_matrix_reference_dimension_width" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIntrinsicMatrixReferenceDimensionWidth() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "intrinsic_matrix_reference_dimension_height" field.</summary>
    public const int IntrinsicMatrixReferenceDimensionHeightFieldNumber = 3;
    private readonly static float IntrinsicMatrixReferenceDimensionHeightDefaultValue = 0F;

    private float intrinsicMatrixReferenceDimensionHeight_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float IntrinsicMatrixReferenceDimensionHeight {
      get { if ((_hasBits0 & 2) != 0) { return intrinsicMatrixReferenceDimensionHeight_; } else { return IntrinsicMatrixReferenceDimensionHeightDefaultValue; } }
      set {
        _hasBits0 |= 2;
        intrinsicMatrixReferenceDimensionHeight_ = value;
      }
    }
    /// <summary>Gets whether the "intrinsic_matrix_reference_dimension_height" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIntrinsicMatrixReferenceDimensionHeight {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "intrinsic_matrix_reference_dimension_height" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIntrinsicMatrixReferenceDimensionHeight() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "extrinsic_matrix" field.</summary>
    public const int ExtrinsicMatrixFieldNumber = 4;
    private static readonly pb::FieldCodec<float> _repeated_extrinsicMatrix_codec
        = pb::FieldCodec.ForFloat(34);
    private readonly pbc::RepeatedField<float> extrinsicMatrix_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// 3x4 row-major matrix relating a camera's position and orientation to a
    /// world or scene coordinate system. Consists of a unitless 3x3 rotation
    /// matrix (R) on the left and a translation (t) 3x1 vector on the right. The
    /// translation vector's units are millimeters. For example:
    ///
    ///            |r1,1  r2,1  r3,1 | t1|
    ///  [R | t] = |r1,2  r2,2  r3,2 | t2|
    ///            |r1,3  r2,3  r3,3 | t3|
    ///
    ///  is stored as [r11, r21, r31, t1, r12, r22, r32, t2, ...]
    ///
    /// See
    /// developer.apple.com/documentation/avfoundation/avcameracalibrationdata/2881130-extrinsicmatrix?language=objc
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<float> ExtrinsicMatrix {
      get { return extrinsicMatrix_; }
    }

    /// <summary>Field number for the "pixel_size" field.</summary>
    public const int PixelSizeFieldNumber = 5;
    private readonly static float PixelSizeDefaultValue = 0F;

    private float pixelSize_;
    /// <summary>
    /// The size, in millimeters, of one image pixel.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float PixelSize {
      get { if ((_hasBits0 & 4) != 0) { return pixelSize_; } else { return PixelSizeDefaultValue; } }
      set {
        _hasBits0 |= 4;
        pixelSize_ = value;
      }
    }
    /// <summary>Gets whether the "pixel_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPixelSize {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "pixel_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPixelSize() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "lens_distortion_lookup_values" field.</summary>
    public const int LensDistortionLookupValuesFieldNumber = 6;
    private static readonly pb::FieldCodec<float> _repeated_lensDistortionLookupValues_codec
        = pb::FieldCodec.ForFloat(50);
    private readonly pbc::RepeatedField<float> lensDistortionLookupValues_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// A list of floating-point values describing radial distortions imparted by
    /// the camera lens, for use in rectifying camera images.
    /// See
    /// developer.apple.com/documentation/avfoundation/avcameracalibrationdata/2881129-lensdistortionlookuptable?language=objc
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<float> LensDistortionLookupValues {
      get { return lensDistortionLookupValues_; }
    }

    /// <summary>Field number for the "inverse_lens_distortion_lookup_values" field.</summary>
    public const int InverseLensDistortionLookupValuesFieldNumber = 7;
    private static readonly pb::FieldCodec<float> _repeated_inverseLensDistortionLookupValues_codec
        = pb::FieldCodec.ForFloat(58);
    private readonly pbc::RepeatedField<float> inverseLensDistortionLookupValues_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// A list of floating-point values describing radial distortions for use in
    /// reapplying camera geometry to a rectified image.
    /// See
    /// developer.apple.com/documentation/avfoundation/avcameracalibrationdata/2881132-inverselensdistortionlookuptable?language=objc
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<float> InverseLensDistortionLookupValues {
      get { return inverseLensDistortionLookupValues_; }
    }

    /// <summary>Field number for the "lens_distortion_center_x" field.</summary>
    public const int LensDistortionCenterXFieldNumber = 8;
    private readonly static float LensDistortionCenterXDefaultValue = 0F;

    private float lensDistortionCenterX_;
    /// <summary>
    /// The offset of the distortion center of the camera lens from the top-left
    /// corner of the image.
    /// See
    /// developer.apple.com/documentation/avfoundation/avcameracalibrationdata/2881131-lensdistortioncenter?language=objc
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float LensDistortionCenterX {
      get { if ((_hasBits0 & 8) != 0) { return lensDistortionCenterX_; } else { return LensDistortionCenterXDefaultValue; } }
      set {
        _hasBits0 |= 8;
        lensDistortionCenterX_ = value;
      }
    }
    /// <summary>Gets whether the "lens_distortion_center_x" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLensDistortionCenterX {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "lens_distortion_center_x" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLensDistortionCenterX() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "lens_distortion_center_y" field.</summary>
    public const int LensDistortionCenterYFieldNumber = 9;
    private readonly static float LensDistortionCenterYDefaultValue = 0F;

    private float lensDistortionCenterY_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float LensDistortionCenterY {
      get { if ((_hasBits0 & 16) != 0) { return lensDistortionCenterY_; } else { return LensDistortionCenterYDefaultValue; } }
      set {
        _hasBits0 |= 16;
        lensDistortionCenterY_ = value;
      }
    }
    /// <summary>Gets whether the "lens_distortion_center_y" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLensDistortionCenterY {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "lens_distortion_center_y" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLensDistortionCenterY() {
      _hasBits0 &= ~16;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AVCameraCalibrationData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AVCameraCalibrationData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!intrinsicMatrix_.Equals(other.intrinsicMatrix_)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(IntrinsicMatrixReferenceDimensionWidth, other.IntrinsicMatrixReferenceDimensionWidth)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(IntrinsicMatrixReferenceDimensionHeight, other.IntrinsicMatrixReferenceDimensionHeight)) return false;
      if(!extrinsicMatrix_.Equals(other.extrinsicMatrix_)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(PixelSize, other.PixelSize)) return false;
      if(!lensDistortionLookupValues_.Equals(other.lensDistortionLookupValues_)) return false;
      if(!inverseLensDistortionLookupValues_.Equals(other.inverseLensDistortionLookupValues_)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LensDistortionCenterX, other.LensDistortionCenterX)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LensDistortionCenterY, other.LensDistortionCenterY)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= intrinsicMatrix_.GetHashCode();
      if (HasIntrinsicMatrixReferenceDimensionWidth) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(IntrinsicMatrixReferenceDimensionWidth);
      if (HasIntrinsicMatrixReferenceDimensionHeight) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(IntrinsicMatrixReferenceDimensionHeight);
      hash ^= extrinsicMatrix_.GetHashCode();
      if (HasPixelSize) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(PixelSize);
      hash ^= lensDistortionLookupValues_.GetHashCode();
      hash ^= inverseLensDistortionLookupValues_.GetHashCode();
      if (HasLensDistortionCenterX) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LensDistortionCenterX);
      if (HasLensDistortionCenterY) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LensDistortionCenterY);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      intrinsicMatrix_.WriteTo(output, _repeated_intrinsicMatrix_codec);
      if (HasIntrinsicMatrixReferenceDimensionWidth) {
        output.WriteRawTag(21);
        output.WriteFloat(IntrinsicMatrixReferenceDimensionWidth);
      }
      if (HasIntrinsicMatrixReferenceDimensionHeight) {
        output.WriteRawTag(29);
        output.WriteFloat(IntrinsicMatrixReferenceDimensionHeight);
      }
      extrinsicMatrix_.WriteTo(output, _repeated_extrinsicMatrix_codec);
      if (HasPixelSize) {
        output.WriteRawTag(45);
        output.WriteFloat(PixelSize);
      }
      lensDistortionLookupValues_.WriteTo(output, _repeated_lensDistortionLookupValues_codec);
      inverseLensDistortionLookupValues_.WriteTo(output, _repeated_inverseLensDistortionLookupValues_codec);
      if (HasLensDistortionCenterX) {
        output.WriteRawTag(69);
        output.WriteFloat(LensDistortionCenterX);
      }
      if (HasLensDistortionCenterY) {
        output.WriteRawTag(77);
        output.WriteFloat(LensDistortionCenterY);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      intrinsicMatrix_.WriteTo(ref output, _repeated_intrinsicMatrix_codec);
      if (HasIntrinsicMatrixReferenceDimensionWidth) {
        output.WriteRawTag(21);
        output.WriteFloat(IntrinsicMatrixReferenceDimensionWidth);
      }
      if (HasIntrinsicMatrixReferenceDimensionHeight) {
        output.WriteRawTag(29);
        output.WriteFloat(IntrinsicMatrixReferenceDimensionHeight);
      }
      extrinsicMatrix_.WriteTo(ref output, _repeated_extrinsicMatrix_codec);
      if (HasPixelSize) {
        output.WriteRawTag(45);
        output.WriteFloat(PixelSize);
      }
      lensDistortionLookupValues_.WriteTo(ref output, _repeated_lensDistortionLookupValues_codec);
      inverseLensDistortionLookupValues_.WriteTo(ref output, _repeated_inverseLensDistortionLookupValues_codec);
      if (HasLensDistortionCenterX) {
        output.WriteRawTag(69);
        output.WriteFloat(LensDistortionCenterX);
      }
      if (HasLensDistortionCenterY) {
        output.WriteRawTag(77);
        output.WriteFloat(LensDistortionCenterY);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += intrinsicMatrix_.CalculateSize(_repeated_intrinsicMatrix_codec);
      if (HasIntrinsicMatrixReferenceDimensionWidth) {
        size += 1 + 4;
      }
      if (HasIntrinsicMatrixReferenceDimensionHeight) {
        size += 1 + 4;
      }
      size += extrinsicMatrix_.CalculateSize(_repeated_extrinsicMatrix_codec);
      if (HasPixelSize) {
        size += 1 + 4;
      }
      size += lensDistortionLookupValues_.CalculateSize(_repeated_lensDistortionLookupValues_codec);
      size += inverseLensDistortionLookupValues_.CalculateSize(_repeated_inverseLensDistortionLookupValues_codec);
      if (HasLensDistortionCenterX) {
        size += 1 + 4;
      }
      if (HasLensDistortionCenterY) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AVCameraCalibrationData other) {
      if (other == null) {
        return;
      }
      intrinsicMatrix_.Add(other.intrinsicMatrix_);
      if (other.HasIntrinsicMatrixReferenceDimensionWidth) {
        IntrinsicMatrixReferenceDimensionWidth = other.IntrinsicMatrixReferenceDimensionWidth;
      }
      if (other.HasIntrinsicMatrixReferenceDimensionHeight) {
        IntrinsicMatrixReferenceDimensionHeight = other.IntrinsicMatrixReferenceDimensionHeight;
      }
      extrinsicMatrix_.Add(other.extrinsicMatrix_);
      if (other.HasPixelSize) {
        PixelSize = other.PixelSize;
      }
      lensDistortionLookupValues_.Add(other.lensDistortionLookupValues_);
      inverseLensDistortionLookupValues_.Add(other.inverseLensDistortionLookupValues_);
      if (other.HasLensDistortionCenterX) {
        LensDistortionCenterX = other.LensDistortionCenterX;
      }
      if (other.HasLensDistortionCenterY) {
        LensDistortionCenterY = other.LensDistortionCenterY;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 13: {
            intrinsicMatrix_.AddEntriesFrom(input, _repeated_intrinsicMatrix_codec);
            break;
          }
          case 21: {
            IntrinsicMatrixReferenceDimensionWidth = input.ReadFloat();
            break;
          }
          case 29: {
            IntrinsicMatrixReferenceDimensionHeight = input.ReadFloat();
            break;
          }
          case 34:
          case 37: {
            extrinsicMatrix_.AddEntriesFrom(input, _repeated_extrinsicMatrix_codec);
            break;
          }
          case 45: {
            PixelSize = input.ReadFloat();
            break;
          }
          case 50:
          case 53: {
            lensDistortionLookupValues_.AddEntriesFrom(input, _repeated_lensDistortionLookupValues_codec);
            break;
          }
          case 58:
          case 61: {
            inverseLensDistortionLookupValues_.AddEntriesFrom(input, _repeated_inverseLensDistortionLookupValues_codec);
            break;
          }
          case 69: {
            LensDistortionCenterX = input.ReadFloat();
            break;
          }
          case 77: {
            LensDistortionCenterY = input.ReadFloat();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 13: {
            intrinsicMatrix_.AddEntriesFrom(ref input, _repeated_intrinsicMatrix_codec);
            break;
          }
          case 21: {
            IntrinsicMatrixReferenceDimensionWidth = input.ReadFloat();
            break;
          }
          case 29: {
            IntrinsicMatrixReferenceDimensionHeight = input.ReadFloat();
            break;
          }
          case 34:
          case 37: {
            extrinsicMatrix_.AddEntriesFrom(ref input, _repeated_extrinsicMatrix_codec);
            break;
          }
          case 45: {
            PixelSize = input.ReadFloat();
            break;
          }
          case 50:
          case 53: {
            lensDistortionLookupValues_.AddEntriesFrom(ref input, _repeated_lensDistortionLookupValues_codec);
            break;
          }
          case 58:
          case 61: {
            inverseLensDistortionLookupValues_.AddEntriesFrom(ref input, _repeated_inverseLensDistortionLookupValues_codec);
            break;
          }
          case 69: {
            LensDistortionCenterX = input.ReadFloat();
            break;
          }
          case 77: {
            LensDistortionCenterY = input.ReadFloat();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Container for depth data information.
  /// See developer.apple.com/documentation/avfoundation/avdepthdata for more info.
  /// </summary>
  public sealed partial class AVDepthData : pb::IMessage<AVDepthData>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AVDepthData> _parser = new pb::MessageParser<AVDepthData>(() => new AVDepthData());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AVDepthData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.ARCaptureMetadataReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AVDepthData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AVDepthData(AVDepthData other) : this() {
      _hasBits0 = other._hasBits0;
      depthDataMap_ = other.depthDataMap_;
      depthDataType_ = other.depthDataType_;
      depthDataAccuracy_ = other.depthDataAccuracy_;
      depthDataFiltered_ = other.depthDataFiltered_;
      depthDataQuality_ = other.depthDataQuality_;
      cameraCalibrationData_ = other.cameraCalibrationData_ != null ? other.cameraCalibrationData_.Clone() : null;
      depthDataMapOriginalMinimumValue_ = other.depthDataMapOriginalMinimumValue_;
      depthDataMapOriginalMaximumValue_ = other.depthDataMapOriginalMaximumValue_;
      depthDataMapWidth_ = other.depthDataMapWidth_;
      depthDataMapHeight_ = other.depthDataMapHeight_;
      depthDataMapRawValues_ = other.depthDataMapRawValues_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AVDepthData Clone() {
      return new AVDepthData(this);
    }

    /// <summary>Field number for the "depth_data_map" field.</summary>
    public const int DepthDataMapFieldNumber = 1;
    private readonly static pb::ByteString DepthDataMapDefaultValue = pb::ByteString.Empty;

    private pb::ByteString depthDataMap_;
    /// <summary>
    /// PNG representation of the grayscale depth data map. See discussion about
    /// depth_data_map_original_minimum_value, below, for information about how
    /// to interpret the pixel values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString DepthDataMap {
      get { return depthDataMap_ ?? DepthDataMapDefaultValue; }
      set {
        depthDataMap_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "depth_data_map" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDepthDataMap {
      get { return depthDataMap_ != null; }
    }
    /// <summary>Clears the value of the "depth_data_map" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDepthDataMap() {
      depthDataMap_ = null;
    }

    /// <summary>Field number for the "depth_data_type" field.</summary>
    public const int DepthDataTypeFieldNumber = 2;
    private readonly static string DepthDataTypeDefaultValue = "";

    private string depthDataType_;
    /// <summary>
    /// Pixel format type of the original captured depth data.
    /// See
    /// developer.apple.com/documentation/corevideo/1563591-pixel_format_identifiers?language=objc
    /// for the complete list of possible pixel format types. This value represents
    /// a string for the associated OSType/FourCharCode.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DepthDataType {
      get { return depthDataType_ ?? DepthDataTypeDefaultValue; }
      set {
        depthDataType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "depth_data_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDepthDataType {
      get { return depthDataType_ != null; }
    }
    /// <summary>Clears the value of the "depth_data_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDepthDataType() {
      depthDataType_ = null;
    }

    /// <summary>Field number for the "depth_data_accuracy" field.</summary>
    public const int DepthDataAccuracyFieldNumber = 3;
    private readonly static global::Mediapipe.AVDepthData.Types.Accuracy DepthDataAccuracyDefaultValue = global::Mediapipe.AVDepthData.Types.Accuracy.Relative;

    private global::Mediapipe.AVDepthData.Types.Accuracy depthDataAccuracy_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.AVDepthData.Types.Accuracy DepthDataAccuracy {
      get { if ((_hasBits0 & 1) != 0) { return depthDataAccuracy_; } else { return DepthDataAccuracyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        depthDataAccuracy_ = value;
      }
    }
    /// <summary>Gets whether the "depth_data_accuracy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDepthDataAccuracy {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "depth_data_accuracy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDepthDataAccuracy() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "depth_data_filtered" field.</summary>
    public const int DepthDataFilteredFieldNumber = 4;
    private readonly static bool DepthDataFilteredDefaultValue = false;

    private bool depthDataFiltered_;
    /// <summary>
    /// Indicates whether the depth_data_map contains temporally smoothed data.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool DepthDataFiltered {
      get { if ((_hasBits0 & 2) != 0) { return depthDataFiltered_; } else { return DepthDataFilteredDefaultValue; } }
      set {
        _hasBits0 |= 2;
        depthDataFiltered_ = value;
      }
    }
    /// <summary>Gets whether the "depth_data_filtered" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDepthDataFiltered {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "depth_data_filtered" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDepthDataFiltered() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "depth_data_quality" field.</summary>
    public const int DepthDataQualityFieldNumber = 5;
    private readonly static global::Mediapipe.AVDepthData.Types.Quality DepthDataQualityDefaultValue = global::Mediapipe.AVDepthData.Types.Quality.UndefinedQuality;

    private global::Mediapipe.AVDepthData.Types.Quality depthDataQuality_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.AVDepthData.Types.Quality DepthDataQuality {
      get { if ((_hasBits0 & 4) != 0) { return depthDataQuality_; } else { return DepthDataQualityDefaultValue; } }
      set {
        _hasBits0 |= 4;
        depthDataQuality_ = value;
      }
    }
    /// <summary>Gets whether the "depth_data_quality" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDepthDataQuality {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "depth_data_quality" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDepthDataQuality() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "camera_calibration_data" field.</summary>
    public const int CameraCalibrationDataFieldNumber = 6;
    private global::Mediapipe.AVCameraCalibrationData cameraCalibrationData_;
    /// <summary>
    /// Associated calibration data for the depth_data_map.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.AVCameraCalibrationData CameraCalibrationData {
      get { return cameraCalibrationData_; }
      set {
        cameraCalibrationData_ = value;
      }
    }

    /// <summary>Field number for the "depth_data_map_original_minimum_value" field.</summary>
    public const int DepthDataMapOriginalMinimumValueFieldNumber = 7;
    private readonly static float DepthDataMapOriginalMinimumValueDefaultValue = 0F;

    private float depthDataMapOriginalMinimumValue_;
    /// <summary>
    /// The original range of values expressed by the depth_data_map, before
    /// grayscale normalization. For example, if the minimum and maximum values
    /// indicate a range of [0.5, 2.2], and the depth_data_type value indicates
    /// it was a depth map, then white pixels (255, 255, 255) will map to 0.5 and
    /// black pixels (0, 0, 0) will map to 2.2 with the grayscale range linearly
    /// interpolated inbetween. Conversely, if the depth_data_type value indicates
    /// it was a disparity map, then white pixels will map to 2.2 and black pixels
    /// will map to 0.5.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float DepthDataMapOriginalMinimumValue {
      get { if ((_hasBits0 & 8) != 0) { return depthDataMapOriginalMinimumValue_; } else { return DepthDataMapOriginalMinimumValueDefaultValue; } }
      set {
        _hasBits0 |= 8;
        depthDataMapOriginalMinimumValue_ = value;
      }
    }
    /// <summary>Gets whether the "depth_data_map_original_minimum_value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDepthDataMapOriginalMinimumValue {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "depth_data_map_original_minimum_value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDepthDataMapOriginalMinimumValue() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "depth_data_map_original_maximum_value" field.</summary>
    public const int DepthDataMapOriginalMaximumValueFieldNumber = 8;
    private readonly static float DepthDataMapOriginalMaximumValueDefaultValue = 0F;

    private float depthDataMapOriginalMaximumValue_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float DepthDataMapOriginalMaximumValue {
      get { if ((_hasBits0 & 16) != 0) { return depthDataMapOriginalMaximumValue_; } else { return DepthDataMapOriginalMaximumValueDefaultValue; } }
      set {
        _hasBits0 |= 16;
        depthDataMapOriginalMaximumValue_ = value;
      }
    }
    /// <summary>Gets whether the "depth_data_map_original_maximum_value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDepthDataMapOriginalMaximumValue {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "depth_data_map_original_maximum_value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDepthDataMapOriginalMaximumValue() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "depth_data_map_width" field.</summary>
    public const int DepthDataMapWidthFieldNumber = 9;
    private readonly static int DepthDataMapWidthDefaultValue = 0;

    private int depthDataMapWidth_;
    /// <summary>
    /// The width of the depth buffer map.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int DepthDataMapWidth {
      get { if ((_hasBits0 & 32) != 0) { return depthDataMapWidth_; } else { return DepthDataMapWidthDefaultValue; } }
      set {
        _hasBits0 |= 32;
        depthDataMapWidth_ = value;
      }
    }
    /// <summary>Gets whether the "depth_data_map_width" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDepthDataMapWidth {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "depth_data_map_width" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDepthDataMapWidth() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "depth_data_map_height" field.</summary>
    public const int DepthDataMapHeightFieldNumber = 10;
    private readonly static int DepthDataMapHeightDefaultValue = 0;

    private int depthDataMapHeight_;
    /// <summary>
    /// The height of the depth buffer map.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int DepthDataMapHeight {
      get { if ((_hasBits0 & 64) != 0) { return depthDataMapHeight_; } else { return DepthDataMapHeightDefaultValue; } }
      set {
        _hasBits0 |= 64;
        depthDataMapHeight_ = value;
      }
    }
    /// <summary>Gets whether the "depth_data_map_height" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDepthDataMapHeight {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "depth_data_map_height" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDepthDataMapHeight() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "depth_data_map_raw_values" field.</summary>
    public const int DepthDataMapRawValuesFieldNumber = 11;
    private readonly static pb::ByteString DepthDataMapRawValuesDefaultValue = pb::ByteString.Empty;

    private pb::ByteString depthDataMapRawValues_;
    /// <summary>
    /// The row-major flattened array of the depth buffer map pixels. This will be
    /// either a float32 or float16 byte array, depending on 'depth_data_type'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString DepthDataMapRawValues {
      get { return depthDataMapRawValues_ ?? DepthDataMapRawValuesDefaultValue; }
      set {
        depthDataMapRawValues_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "depth_data_map_raw_values" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDepthDataMapRawValues {
      get { return depthDataMapRawValues_ != null; }
    }
    /// <summary>Clears the value of the "depth_data_map_raw_values" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDepthDataMapRawValues() {
      depthDataMapRawValues_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AVDepthData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AVDepthData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DepthDataMap != other.DepthDataMap) return false;
      if (DepthDataType != other.DepthDataType) return false;
      if (DepthDataAccuracy != other.DepthDataAccuracy) return false;
      if (DepthDataFiltered != other.DepthDataFiltered) return false;
      if (DepthDataQuality != other.DepthDataQuality) return false;
      if (!object.Equals(CameraCalibrationData, other.CameraCalibrationData)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(DepthDataMapOriginalMinimumValue, other.DepthDataMapOriginalMinimumValue)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(DepthDataMapOriginalMaximumValue, other.DepthDataMapOriginalMaximumValue)) return false;
      if (DepthDataMapWidth != other.DepthDataMapWidth) return false;
      if (DepthDataMapHeight != other.DepthDataMapHeight) return false;
      if (DepthDataMapRawValues != other.DepthDataMapRawValues) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasDepthDataMap) hash ^= DepthDataMap.GetHashCode();
      if (HasDepthDataType) hash ^= DepthDataType.GetHashCode();
      if (HasDepthDataAccuracy) hash ^= DepthDataAccuracy.GetHashCode();
      if (HasDepthDataFiltered) hash ^= DepthDataFiltered.GetHashCode();
      if (HasDepthDataQuality) hash ^= DepthDataQuality.GetHashCode();
      if (cameraCalibrationData_ != null) hash ^= CameraCalibrationData.GetHashCode();
      if (HasDepthDataMapOriginalMinimumValue) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(DepthDataMapOriginalMinimumValue);
      if (HasDepthDataMapOriginalMaximumValue) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(DepthDataMapOriginalMaximumValue);
      if (HasDepthDataMapWidth) hash ^= DepthDataMapWidth.GetHashCode();
      if (HasDepthDataMapHeight) hash ^= DepthDataMapHeight.GetHashCode();
      if (HasDepthDataMapRawValues) hash ^= DepthDataMapRawValues.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasDepthDataMap) {
        output.WriteRawTag(10);
        output.WriteBytes(DepthDataMap);
      }
      if (HasDepthDataType) {
        output.WriteRawTag(18);
        output.WriteString(DepthDataType);
      }
      if (HasDepthDataAccuracy) {
        output.WriteRawTag(24);
        output.WriteEnum((int) DepthDataAccuracy);
      }
      if (HasDepthDataFiltered) {
        output.WriteRawTag(32);
        output.WriteBool(DepthDataFiltered);
      }
      if (HasDepthDataQuality) {
        output.WriteRawTag(40);
        output.WriteEnum((int) DepthDataQuality);
      }
      if (cameraCalibrationData_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(CameraCalibrationData);
      }
      if (HasDepthDataMapOriginalMinimumValue) {
        output.WriteRawTag(61);
        output.WriteFloat(DepthDataMapOriginalMinimumValue);
      }
      if (HasDepthDataMapOriginalMaximumValue) {
        output.WriteRawTag(69);
        output.WriteFloat(DepthDataMapOriginalMaximumValue);
      }
      if (HasDepthDataMapWidth) {
        output.WriteRawTag(72);
        output.WriteInt32(DepthDataMapWidth);
      }
      if (HasDepthDataMapHeight) {
        output.WriteRawTag(80);
        output.WriteInt32(DepthDataMapHeight);
      }
      if (HasDepthDataMapRawValues) {
        output.WriteRawTag(90);
        output.WriteBytes(DepthDataMapRawValues);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasDepthDataMap) {
        output.WriteRawTag(10);
        output.WriteBytes(DepthDataMap);
      }
      if (HasDepthDataType) {
        output.WriteRawTag(18);
        output.WriteString(DepthDataType);
      }
      if (HasDepthDataAccuracy) {
        output.WriteRawTag(24);
        output.WriteEnum((int) DepthDataAccuracy);
      }
      if (HasDepthDataFiltered) {
        output.WriteRawTag(32);
        output.WriteBool(DepthDataFiltered);
      }
      if (HasDepthDataQuality) {
        output.WriteRawTag(40);
        output.WriteEnum((int) DepthDataQuality);
      }
      if (cameraCalibrationData_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(CameraCalibrationData);
      }
      if (HasDepthDataMapOriginalMinimumValue) {
        output.WriteRawTag(61);
        output.WriteFloat(DepthDataMapOriginalMinimumValue);
      }
      if (HasDepthDataMapOriginalMaximumValue) {
        output.WriteRawTag(69);
        output.WriteFloat(DepthDataMapOriginalMaximumValue);
      }
      if (HasDepthDataMapWidth) {
        output.WriteRawTag(72);
        output.WriteInt32(DepthDataMapWidth);
      }
      if (HasDepthDataMapHeight) {
        output.WriteRawTag(80);
        output.WriteInt32(DepthDataMapHeight);
      }
      if (HasDepthDataMapRawValues) {
        output.WriteRawTag(90);
        output.WriteBytes(DepthDataMapRawValues);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasDepthDataMap) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(DepthDataMap);
      }
      if (HasDepthDataType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DepthDataType);
      }
      if (HasDepthDataAccuracy) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DepthDataAccuracy);
      }
      if (HasDepthDataFiltered) {
        size += 1 + 1;
      }
      if (HasDepthDataQuality) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DepthDataQuality);
      }
      if (cameraCalibrationData_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CameraCalibrationData);
      }
      if (HasDepthDataMapOriginalMinimumValue) {
        size += 1 + 4;
      }
      if (HasDepthDataMapOriginalMaximumValue) {
        size += 1 + 4;
      }
      if (HasDepthDataMapWidth) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(DepthDataMapWidth);
      }
      if (HasDepthDataMapHeight) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(DepthDataMapHeight);
      }
      if (HasDepthDataMapRawValues) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(DepthDataMapRawValues);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AVDepthData other) {
      if (other == null) {
        return;
      }
      if (other.HasDepthDataMap) {
        DepthDataMap = other.DepthDataMap;
      }
      if (other.HasDepthDataType) {
        DepthDataType = other.DepthDataType;
      }
      if (other.HasDepthDataAccuracy) {
        DepthDataAccuracy = other.DepthDataAccuracy;
      }
      if (other.HasDepthDataFiltered) {
        DepthDataFiltered = other.DepthDataFiltered;
      }
      if (other.HasDepthDataQuality) {
        DepthDataQuality = other.DepthDataQuality;
      }
      if (other.cameraCalibrationData_ != null) {
        if (cameraCalibrationData_ == null) {
          CameraCalibrationData = new global::Mediapipe.AVCameraCalibrationData();
        }
        CameraCalibrationData.MergeFrom(other.CameraCalibrationData);
      }
      if (other.HasDepthDataMapOriginalMinimumValue) {
        DepthDataMapOriginalMinimumValue = other.DepthDataMapOriginalMinimumValue;
      }
      if (other.HasDepthDataMapOriginalMaximumValue) {
        DepthDataMapOriginalMaximumValue = other.DepthDataMapOriginalMaximumValue;
      }
      if (other.HasDepthDataMapWidth) {
        DepthDataMapWidth = other.DepthDataMapWidth;
      }
      if (other.HasDepthDataMapHeight) {
        DepthDataMapHeight = other.DepthDataMapHeight;
      }
      if (other.HasDepthDataMapRawValues) {
        DepthDataMapRawValues = other.DepthDataMapRawValues;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            DepthDataMap = input.ReadBytes();
            break;
          }
          case 18: {
            DepthDataType = input.ReadString();
            break;
          }
          case 24: {
            DepthDataAccuracy = (global::Mediapipe.AVDepthData.Types.Accuracy) input.ReadEnum();
            break;
          }
          case 32: {
            DepthDataFiltered = input.ReadBool();
            break;
          }
          case 40: {
            DepthDataQuality = (global::Mediapipe.AVDepthData.Types.Quality) input.ReadEnum();
            break;
          }
          case 50: {
            if (cameraCalibrationData_ == null) {
              CameraCalibrationData = new global::Mediapipe.AVCameraCalibrationData();
            }
            input.ReadMessage(CameraCalibrationData);
            break;
          }
          case 61: {
            DepthDataMapOriginalMinimumValue = input.ReadFloat();
            break;
          }
          case 69: {
            DepthDataMapOriginalMaximumValue = input.ReadFloat();
            break;
          }
          case 72: {
            DepthDataMapWidth = input.ReadInt32();
            break;
          }
          case 80: {
            DepthDataMapHeight = input.ReadInt32();
            break;
          }
          case 90: {
            DepthDataMapRawValues = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            DepthDataMap = input.ReadBytes();
            break;
          }
          case 18: {
            DepthDataType = input.ReadString();
            break;
          }
          case 24: {
            DepthDataAccuracy = (global::Mediapipe.AVDepthData.Types.Accuracy) input.ReadEnum();
            break;
          }
          case 32: {
            DepthDataFiltered = input.ReadBool();
            break;
          }
          case 40: {
            DepthDataQuality = (global::Mediapipe.AVDepthData.Types.Quality) input.ReadEnum();
            break;
          }
          case 50: {
            if (cameraCalibrationData_ == null) {
              CameraCalibrationData = new global::Mediapipe.AVCameraCalibrationData();
            }
            input.ReadMessage(CameraCalibrationData);
            break;
          }
          case 61: {
            DepthDataMapOriginalMinimumValue = input.ReadFloat();
            break;
          }
          case 69: {
            DepthDataMapOriginalMaximumValue = input.ReadFloat();
            break;
          }
          case 72: {
            DepthDataMapWidth = input.ReadInt32();
            break;
          }
          case 80: {
            DepthDataMapHeight = input.ReadInt32();
            break;
          }
          case 90: {
            DepthDataMapRawValues = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the AVDepthData message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Indicates the general accuracy of the depth_data_map.
      /// See developer.apple.com/documentation/avfoundation/avdepthdataaccuracy for
      /// more information.
      /// </summary>
      public enum Accuracy {
        [pbr::OriginalName("UNDEFINED_ACCURACY")] UndefinedAccuracy = 0,
        /// <summary>
        /// Values in the depth map are usable for foreground/background separation
        /// but are not absolutely accurate in the physical world.
        /// </summary>
        [pbr::OriginalName("RELATIVE")] Relative = 1,
        /// <summary>
        /// Values in the depth map are absolutely accurate in the physical world.
        /// </summary>
        [pbr::OriginalName("ABSOLUTE")] Absolute = 2,
      }

      /// <summary>
      /// Quality of the depth_data_map.
      /// </summary>
      public enum Quality {
        [pbr::OriginalName("UNDEFINED_QUALITY")] UndefinedQuality = 0,
        [pbr::OriginalName("HIGH")] High = 1,
        [pbr::OriginalName("LOW")] Low = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// Estimated scene lighting information associated with a captured video frame.
  /// See developer.apple.com/documentation/arkit/arlightestimate for more info.
  /// </summary>
  public sealed partial class ARLightEstimate : pb::IMessage<ARLightEstimate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ARLightEstimate> _parser = new pb::MessageParser<ARLightEstimate>(() => new ARLightEstimate());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ARLightEstimate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.ARCaptureMetadataReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARLightEstimate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARLightEstimate(ARLightEstimate other) : this() {
      _hasBits0 = other._hasBits0;
      ambientIntensity_ = other.ambientIntensity_;
      ambientColorTemperature_ = other.ambientColorTemperature_;
      sphericalHarmonicsCoefficients_ = other.sphericalHarmonicsCoefficients_.Clone();
      primaryLightDirection_ = other.primaryLightDirection_ != null ? other.primaryLightDirection_.Clone() : null;
      primaryLightIntensity_ = other.primaryLightIntensity_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARLightEstimate Clone() {
      return new ARLightEstimate(this);
    }

    /// <summary>Field number for the "ambient_intensity" field.</summary>
    public const int AmbientIntensityFieldNumber = 1;
    private readonly static double AmbientIntensityDefaultValue = 0D;

    private double ambientIntensity_;
    /// <summary>
    /// The estimated intensity, in lumens, of ambient light throughout the scene.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double AmbientIntensity {
      get { if ((_hasBits0 & 1) != 0) { return ambientIntensity_; } else { return AmbientIntensityDefaultValue; } }
      set {
        _hasBits0 |= 1;
        ambientIntensity_ = value;
      }
    }
    /// <summary>Gets whether the "ambient_intensity" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAmbientIntensity {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "ambient_intensity" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAmbientIntensity() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "ambient_color_temperature" field.</summary>
    public const int AmbientColorTemperatureFieldNumber = 2;
    private readonly static double AmbientColorTemperatureDefaultValue = 0D;

    private double ambientColorTemperature_;
    /// <summary>
    /// The estimated color temperature, in degrees Kelvin, of ambient light
    /// throughout the scene.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double AmbientColorTemperature {
      get { if ((_hasBits0 & 2) != 0) { return ambientColorTemperature_; } else { return AmbientColorTemperatureDefaultValue; } }
      set {
        _hasBits0 |= 2;
        ambientColorTemperature_ = value;
      }
    }
    /// <summary>Gets whether the "ambient_color_temperature" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAmbientColorTemperature {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "ambient_color_temperature" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAmbientColorTemperature() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "spherical_harmonics_coefficients" field.</summary>
    public const int SphericalHarmonicsCoefficientsFieldNumber = 3;
    private static readonly pb::FieldCodec<float> _repeated_sphericalHarmonicsCoefficients_codec
        = pb::FieldCodec.ForFloat(26);
    private readonly pbc::RepeatedField<float> sphericalHarmonicsCoefficients_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// Data describing the estimated lighting environment in all directions.
    /// Second-level spherical harmonics in separate red, green, and blue data
    /// planes. Thus, this buffer contains 3 sets of 9 coefficients, or a total of
    /// 27 values.
    /// See
    /// https://developer.apple.com/documentation/arkit/ardirectionallightestimate/2928222-sphericalharmonicscoefficients?language=objc
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<float> SphericalHarmonicsCoefficients {
      get { return sphericalHarmonicsCoefficients_; }
    }

    /// <summary>Field number for the "primary_light_direction" field.</summary>
    public const int PrimaryLightDirectionFieldNumber = 4;
    private global::Mediapipe.ARLightEstimate.Types.DirectionVector primaryLightDirection_;
    /// <summary>
    /// A vector indicating the orientation of the strongest directional light
    /// source, normalized in the world-coordinate space.
    /// See
    /// https://developer.apple.com/documentation/arkit/ardirectionallightestimate/2928221-primarylightdirection?language=objc
    /// for more information;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ARLightEstimate.Types.DirectionVector PrimaryLightDirection {
      get { return primaryLightDirection_; }
      set {
        primaryLightDirection_ = value;
      }
    }

    /// <summary>Field number for the "primary_light_intensity" field.</summary>
    public const int PrimaryLightIntensityFieldNumber = 5;
    private readonly static float PrimaryLightIntensityDefaultValue = 0F;

    private float primaryLightIntensity_;
    /// <summary>
    /// The estimated intensity, in lumens, of the strongest directional light
    /// source in the scene.
    /// See
    /// https://developer.apple.com/documentation/arkit/ardirectionallightestimate/2928219-primarylightintensity?language=objc
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float PrimaryLightIntensity {
      get { if ((_hasBits0 & 4) != 0) { return primaryLightIntensity_; } else { return PrimaryLightIntensityDefaultValue; } }
      set {
        _hasBits0 |= 4;
        primaryLightIntensity_ = value;
      }
    }
    /// <summary>Gets whether the "primary_light_intensity" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPrimaryLightIntensity {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "primary_light_intensity" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPrimaryLightIntensity() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ARLightEstimate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ARLightEstimate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(AmbientIntensity, other.AmbientIntensity)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(AmbientColorTemperature, other.AmbientColorTemperature)) return false;
      if(!sphericalHarmonicsCoefficients_.Equals(other.sphericalHarmonicsCoefficients_)) return false;
      if (!object.Equals(PrimaryLightDirection, other.PrimaryLightDirection)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(PrimaryLightIntensity, other.PrimaryLightIntensity)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasAmbientIntensity) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(AmbientIntensity);
      if (HasAmbientColorTemperature) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(AmbientColorTemperature);
      hash ^= sphericalHarmonicsCoefficients_.GetHashCode();
      if (primaryLightDirection_ != null) hash ^= PrimaryLightDirection.GetHashCode();
      if (HasPrimaryLightIntensity) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(PrimaryLightIntensity);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasAmbientIntensity) {
        output.WriteRawTag(9);
        output.WriteDouble(AmbientIntensity);
      }
      if (HasAmbientColorTemperature) {
        output.WriteRawTag(17);
        output.WriteDouble(AmbientColorTemperature);
      }
      sphericalHarmonicsCoefficients_.WriteTo(output, _repeated_sphericalHarmonicsCoefficients_codec);
      if (primaryLightDirection_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(PrimaryLightDirection);
      }
      if (HasPrimaryLightIntensity) {
        output.WriteRawTag(45);
        output.WriteFloat(PrimaryLightIntensity);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasAmbientIntensity) {
        output.WriteRawTag(9);
        output.WriteDouble(AmbientIntensity);
      }
      if (HasAmbientColorTemperature) {
        output.WriteRawTag(17);
        output.WriteDouble(AmbientColorTemperature);
      }
      sphericalHarmonicsCoefficients_.WriteTo(ref output, _repeated_sphericalHarmonicsCoefficients_codec);
      if (primaryLightDirection_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(PrimaryLightDirection);
      }
      if (HasPrimaryLightIntensity) {
        output.WriteRawTag(45);
        output.WriteFloat(PrimaryLightIntensity);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasAmbientIntensity) {
        size += 1 + 8;
      }
      if (HasAmbientColorTemperature) {
        size += 1 + 8;
      }
      size += sphericalHarmonicsCoefficients_.CalculateSize(_repeated_sphericalHarmonicsCoefficients_codec);
      if (primaryLightDirection_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PrimaryLightDirection);
      }
      if (HasPrimaryLightIntensity) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ARLightEstimate other) {
      if (other == null) {
        return;
      }
      if (other.HasAmbientIntensity) {
        AmbientIntensity = other.AmbientIntensity;
      }
      if (other.HasAmbientColorTemperature) {
        AmbientColorTemperature = other.AmbientColorTemperature;
      }
      sphericalHarmonicsCoefficients_.Add(other.sphericalHarmonicsCoefficients_);
      if (other.primaryLightDirection_ != null) {
        if (primaryLightDirection_ == null) {
          PrimaryLightDirection = new global::Mediapipe.ARLightEstimate.Types.DirectionVector();
        }
        PrimaryLightDirection.MergeFrom(other.PrimaryLightDirection);
      }
      if (other.HasPrimaryLightIntensity) {
        PrimaryLightIntensity = other.PrimaryLightIntensity;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 9: {
            AmbientIntensity = input.ReadDouble();
            break;
          }
          case 17: {
            AmbientColorTemperature = input.ReadDouble();
            break;
          }
          case 26:
          case 29: {
            sphericalHarmonicsCoefficients_.AddEntriesFrom(input, _repeated_sphericalHarmonicsCoefficients_codec);
            break;
          }
          case 34: {
            if (primaryLightDirection_ == null) {
              PrimaryLightDirection = new global::Mediapipe.ARLightEstimate.Types.DirectionVector();
            }
            input.ReadMessage(PrimaryLightDirection);
            break;
          }
          case 45: {
            PrimaryLightIntensity = input.ReadFloat();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 9: {
            AmbientIntensity = input.ReadDouble();
            break;
          }
          case 17: {
            AmbientColorTemperature = input.ReadDouble();
            break;
          }
          case 26:
          case 29: {
            sphericalHarmonicsCoefficients_.AddEntriesFrom(ref input, _repeated_sphericalHarmonicsCoefficients_codec);
            break;
          }
          case 34: {
            if (primaryLightDirection_ == null) {
              PrimaryLightDirection = new global::Mediapipe.ARLightEstimate.Types.DirectionVector();
            }
            input.ReadMessage(PrimaryLightDirection);
            break;
          }
          case 45: {
            PrimaryLightIntensity = input.ReadFloat();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ARLightEstimate message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public sealed partial class DirectionVector : pb::IMessage<DirectionVector>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<DirectionVector> _parser = new pb::MessageParser<DirectionVector>(() => new DirectionVector());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<DirectionVector> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.ARLightEstimate.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DirectionVector() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DirectionVector(DirectionVector other) : this() {
          _hasBits0 = other._hasBits0;
          x_ = other.x_;
          y_ = other.y_;
          z_ = other.z_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DirectionVector Clone() {
          return new DirectionVector(this);
        }

        /// <summary>Field number for the "x" field.</summary>
        public const int XFieldNumber = 1;
        private readonly static float XDefaultValue = 0F;

        private float x_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float X {
          get { if ((_hasBits0 & 1) != 0) { return x_; } else { return XDefaultValue; } }
          set {
            _hasBits0 |= 1;
            x_ = value;
          }
        }
        /// <summary>Gets whether the "x" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasX {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "x" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearX() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "y" field.</summary>
        public const int YFieldNumber = 2;
        private readonly static float YDefaultValue = 0F;

        private float y_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Y {
          get { if ((_hasBits0 & 2) != 0) { return y_; } else { return YDefaultValue; } }
          set {
            _hasBits0 |= 2;
            y_ = value;
          }
        }
        /// <summary>Gets whether the "y" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasY {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "y" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearY() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "z" field.</summary>
        public const int ZFieldNumber = 3;
        private readonly static float ZDefaultValue = 0F;

        private float z_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Z {
          get { if ((_hasBits0 & 4) != 0) { return z_; } else { return ZDefaultValue; } }
          set {
            _hasBits0 |= 4;
            z_ = value;
          }
        }
        /// <summary>Gets whether the "z" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasZ {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "z" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearZ() {
          _hasBits0 &= ~4;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as DirectionVector);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(DirectionVector other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(X, other.X)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Y, other.Y)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Z, other.Z)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasX) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(X);
          if (HasY) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Y);
          if (HasZ) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Z);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasX) {
            output.WriteRawTag(13);
            output.WriteFloat(X);
          }
          if (HasY) {
            output.WriteRawTag(21);
            output.WriteFloat(Y);
          }
          if (HasZ) {
            output.WriteRawTag(29);
            output.WriteFloat(Z);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasX) {
            output.WriteRawTag(13);
            output.WriteFloat(X);
          }
          if (HasY) {
            output.WriteRawTag(21);
            output.WriteFloat(Y);
          }
          if (HasZ) {
            output.WriteRawTag(29);
            output.WriteFloat(Z);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasX) {
            size += 1 + 4;
          }
          if (HasY) {
            size += 1 + 4;
          }
          if (HasZ) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(DirectionVector other) {
          if (other == null) {
            return;
          }
          if (other.HasX) {
            X = other.X;
          }
          if (other.HasY) {
            Y = other.Y;
          }
          if (other.HasZ) {
            Z = other.Z;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                X = input.ReadFloat();
                break;
              }
              case 21: {
                Y = input.ReadFloat();
                break;
              }
              case 29: {
                Z = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 13: {
                X = input.ReadFloat();
                break;
              }
              case 21: {
                Y = input.ReadFloat();
                break;
              }
              case 29: {
                Z = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Information about the camera position and imaging characteristics for a
  /// captured video frame.
  /// See developer.apple.com/documentation/arkit/arcamera for more information.
  /// </summary>
  public sealed partial class ARCamera : pb::IMessage<ARCamera>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ARCamera> _parser = new pb::MessageParser<ARCamera>(() => new ARCamera());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ARCamera> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.ARCaptureMetadataReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARCamera() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARCamera(ARCamera other) : this() {
      _hasBits0 = other._hasBits0;
      trackingState_ = other.trackingState_;
      trackingStateReason_ = other.trackingStateReason_;
      transform_ = other.transform_.Clone();
      eulerAngles_ = other.eulerAngles_ != null ? other.eulerAngles_.Clone() : null;
      imageResolutionWidth_ = other.imageResolutionWidth_;
      imageResolutionHeight_ = other.imageResolutionHeight_;
      intrinsics_ = other.intrinsics_.Clone();
      projectionMatrix_ = other.projectionMatrix_.Clone();
      viewMatrix_ = other.viewMatrix_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARCamera Clone() {
      return new ARCamera(this);
    }

    /// <summary>Field number for the "tracking_state" field.</summary>
    public const int TrackingStateFieldNumber = 1;
    private readonly static global::Mediapipe.ARCamera.Types.TrackingState TrackingStateDefaultValue = global::Mediapipe.ARCamera.Types.TrackingState.Unavailable;

    private global::Mediapipe.ARCamera.Types.TrackingState trackingState_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ARCamera.Types.TrackingState TrackingState {
      get { if ((_hasBits0 & 1) != 0) { return trackingState_; } else { return TrackingStateDefaultValue; } }
      set {
        _hasBits0 |= 1;
        trackingState_ = value;
      }
    }
    /// <summary>Gets whether the "tracking_state" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTrackingState {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "tracking_state" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTrackingState() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "tracking_state_reason" field.</summary>
    public const int TrackingStateReasonFieldNumber = 2;
    private readonly static global::Mediapipe.ARCamera.Types.TrackingStateReason TrackingStateReasonDefaultValue = global::Mediapipe.ARCamera.Types.TrackingStateReason.None;

    private global::Mediapipe.ARCamera.Types.TrackingStateReason trackingStateReason_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ARCamera.Types.TrackingStateReason TrackingStateReason {
      get { if ((_hasBits0 & 2) != 0) { return trackingStateReason_; } else { return TrackingStateReasonDefaultValue; } }
      set {
        _hasBits0 |= 2;
        trackingStateReason_ = value;
      }
    }
    /// <summary>Gets whether the "tracking_state_reason" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTrackingStateReason {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "tracking_state_reason" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTrackingStateReason() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "transform" field.</summary>
    public const int TransformFieldNumber = 3;
    private static readonly pb::FieldCodec<float> _repeated_transform_codec
        = pb::FieldCodec.ForFloat(26);
    private readonly pbc::RepeatedField<float> transform_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// 4x4 row-major matrix expressing position and orientation of the camera in
    /// world coordinate space.
    /// See developer.apple.com/documentation/arkit/arcamera/2866108-transform for
    /// more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<float> Transform {
      get { return transform_; }
    }

    /// <summary>Field number for the "euler_angles" field.</summary>
    public const int EulerAnglesFieldNumber = 4;
    private global::Mediapipe.ARCamera.Types.EulerAngles eulerAngles_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ARCamera.Types.EulerAngles EulerAngles {
      get { return eulerAngles_; }
      set {
        eulerAngles_ = value;
      }
    }

    /// <summary>Field number for the "image_resolution_width" field.</summary>
    public const int ImageResolutionWidthFieldNumber = 5;
    private readonly static int ImageResolutionWidthDefaultValue = 0;

    private int imageResolutionWidth_;
    /// <summary>
    /// The width and height, in pixels, of the captured camera image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int ImageResolutionWidth {
      get { if ((_hasBits0 & 4) != 0) { return imageResolutionWidth_; } else { return ImageResolutionWidthDefaultValue; } }
      set {
        _hasBits0 |= 4;
        imageResolutionWidth_ = value;
      }
    }
    /// <summary>Gets whether the "image_resolution_width" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasImageResolutionWidth {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "image_resolution_width" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearImageResolutionWidth() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "image_resolution_height" field.</summary>
    public const int ImageResolutionHeightFieldNumber = 6;
    private readonly static int ImageResolutionHeightDefaultValue = 0;

    private int imageResolutionHeight_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int ImageResolutionHeight {
      get { if ((_hasBits0 & 8) != 0) { return imageResolutionHeight_; } else { return ImageResolutionHeightDefaultValue; } }
      set {
        _hasBits0 |= 8;
        imageResolutionHeight_ = value;
      }
    }
    /// <summary>Gets whether the "image_resolution_height" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasImageResolutionHeight {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "image_resolution_height" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearImageResolutionHeight() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "intrinsics" field.</summary>
    public const int IntrinsicsFieldNumber = 7;
    private static readonly pb::FieldCodec<float> _repeated_intrinsics_codec
        = pb::FieldCodec.ForFloat(58);
    private readonly pbc::RepeatedField<float> intrinsics_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// 3x3 row-major matrix that converts between the 2D camera plane and 3D world
    /// coordinate space.
    /// See developer.apple.com/documentation/arkit/arcamera/2875730-intrinsics for
    /// usage information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<float> Intrinsics {
      get { return intrinsics_; }
    }

    /// <summary>Field number for the "projection_matrix" field.</summary>
    public const int ProjectionMatrixFieldNumber = 8;
    private static readonly pb::FieldCodec<float> _repeated_projectionMatrix_codec
        = pb::FieldCodec.ForFloat(66);
    private readonly pbc::RepeatedField<float> projectionMatrix_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// 4x4 row-major transform matrix appropriate for rendering 3D content to
    /// match the image captured by the camera.
    /// See
    /// developer.apple.com/documentation/arkit/arcamera/2887458-projectionmatrix
    /// for usage information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<float> ProjectionMatrix {
      get { return projectionMatrix_; }
    }

    /// <summary>Field number for the "view_matrix" field.</summary>
    public const int ViewMatrixFieldNumber = 9;
    private static readonly pb::FieldCodec<float> _repeated_viewMatrix_codec
        = pb::FieldCodec.ForFloat(74);
    private readonly pbc::RepeatedField<float> viewMatrix_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// 4x4 row-major transform matrix appropriate for converting from world-space
    /// to camera space. Relativized for the captured_image orientation (i.e.
    /// UILandscapeOrientationRight).
    /// See
    /// https://developer.apple.com/documentation/arkit/arcamera/2921672-viewmatrixfororientation?language=objc
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<float> ViewMatrix {
      get { return viewMatrix_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ARCamera);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ARCamera other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TrackingState != other.TrackingState) return false;
      if (TrackingStateReason != other.TrackingStateReason) return false;
      if(!transform_.Equals(other.transform_)) return false;
      if (!object.Equals(EulerAngles, other.EulerAngles)) return false;
      if (ImageResolutionWidth != other.ImageResolutionWidth) return false;
      if (ImageResolutionHeight != other.ImageResolutionHeight) return false;
      if(!intrinsics_.Equals(other.intrinsics_)) return false;
      if(!projectionMatrix_.Equals(other.projectionMatrix_)) return false;
      if(!viewMatrix_.Equals(other.viewMatrix_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasTrackingState) hash ^= TrackingState.GetHashCode();
      if (HasTrackingStateReason) hash ^= TrackingStateReason.GetHashCode();
      hash ^= transform_.GetHashCode();
      if (eulerAngles_ != null) hash ^= EulerAngles.GetHashCode();
      if (HasImageResolutionWidth) hash ^= ImageResolutionWidth.GetHashCode();
      if (HasImageResolutionHeight) hash ^= ImageResolutionHeight.GetHashCode();
      hash ^= intrinsics_.GetHashCode();
      hash ^= projectionMatrix_.GetHashCode();
      hash ^= viewMatrix_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasTrackingState) {
        output.WriteRawTag(8);
        output.WriteEnum((int) TrackingState);
      }
      if (HasTrackingStateReason) {
        output.WriteRawTag(16);
        output.WriteEnum((int) TrackingStateReason);
      }
      transform_.WriteTo(output, _repeated_transform_codec);
      if (eulerAngles_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(EulerAngles);
      }
      if (HasImageResolutionWidth) {
        output.WriteRawTag(40);
        output.WriteInt32(ImageResolutionWidth);
      }
      if (HasImageResolutionHeight) {
        output.WriteRawTag(48);
        output.WriteInt32(ImageResolutionHeight);
      }
      intrinsics_.WriteTo(output, _repeated_intrinsics_codec);
      projectionMatrix_.WriteTo(output, _repeated_projectionMatrix_codec);
      viewMatrix_.WriteTo(output, _repeated_viewMatrix_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasTrackingState) {
        output.WriteRawTag(8);
        output.WriteEnum((int) TrackingState);
      }
      if (HasTrackingStateReason) {
        output.WriteRawTag(16);
        output.WriteEnum((int) TrackingStateReason);
      }
      transform_.WriteTo(ref output, _repeated_transform_codec);
      if (eulerAngles_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(EulerAngles);
      }
      if (HasImageResolutionWidth) {
        output.WriteRawTag(40);
        output.WriteInt32(ImageResolutionWidth);
      }
      if (HasImageResolutionHeight) {
        output.WriteRawTag(48);
        output.WriteInt32(ImageResolutionHeight);
      }
      intrinsics_.WriteTo(ref output, _repeated_intrinsics_codec);
      projectionMatrix_.WriteTo(ref output, _repeated_projectionMatrix_codec);
      viewMatrix_.WriteTo(ref output, _repeated_viewMatrix_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasTrackingState) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TrackingState);
      }
      if (HasTrackingStateReason) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TrackingStateReason);
      }
      size += transform_.CalculateSize(_repeated_transform_codec);
      if (eulerAngles_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EulerAngles);
      }
      if (HasImageResolutionWidth) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ImageResolutionWidth);
      }
      if (HasImageResolutionHeight) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ImageResolutionHeight);
      }
      size += intrinsics_.CalculateSize(_repeated_intrinsics_codec);
      size += projectionMatrix_.CalculateSize(_repeated_projectionMatrix_codec);
      size += viewMatrix_.CalculateSize(_repeated_viewMatrix_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ARCamera other) {
      if (other == null) {
        return;
      }
      if (other.HasTrackingState) {
        TrackingState = other.TrackingState;
      }
      if (other.HasTrackingStateReason) {
        TrackingStateReason = other.TrackingStateReason;
      }
      transform_.Add(other.transform_);
      if (other.eulerAngles_ != null) {
        if (eulerAngles_ == null) {
          EulerAngles = new global::Mediapipe.ARCamera.Types.EulerAngles();
        }
        EulerAngles.MergeFrom(other.EulerAngles);
      }
      if (other.HasImageResolutionWidth) {
        ImageResolutionWidth = other.ImageResolutionWidth;
      }
      if (other.HasImageResolutionHeight) {
        ImageResolutionHeight = other.ImageResolutionHeight;
      }
      intrinsics_.Add(other.intrinsics_);
      projectionMatrix_.Add(other.projectionMatrix_);
      viewMatrix_.Add(other.viewMatrix_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            TrackingState = (global::Mediapipe.ARCamera.Types.TrackingState) input.ReadEnum();
            break;
          }
          case 16: {
            TrackingStateReason = (global::Mediapipe.ARCamera.Types.TrackingStateReason) input.ReadEnum();
            break;
          }
          case 26:
          case 29: {
            transform_.AddEntriesFrom(input, _repeated_transform_codec);
            break;
          }
          case 34: {
            if (eulerAngles_ == null) {
              EulerAngles = new global::Mediapipe.ARCamera.Types.EulerAngles();
            }
            input.ReadMessage(EulerAngles);
            break;
          }
          case 40: {
            ImageResolutionWidth = input.ReadInt32();
            break;
          }
          case 48: {
            ImageResolutionHeight = input.ReadInt32();
            break;
          }
          case 58:
          case 61: {
            intrinsics_.AddEntriesFrom(input, _repeated_intrinsics_codec);
            break;
          }
          case 66:
          case 69: {
            projectionMatrix_.AddEntriesFrom(input, _repeated_projectionMatrix_codec);
            break;
          }
          case 74:
          case 77: {
            viewMatrix_.AddEntriesFrom(input, _repeated_viewMatrix_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            TrackingState = (global::Mediapipe.ARCamera.Types.TrackingState) input.ReadEnum();
            break;
          }
          case 16: {
            TrackingStateReason = (global::Mediapipe.ARCamera.Types.TrackingStateReason) input.ReadEnum();
            break;
          }
          case 26:
          case 29: {
            transform_.AddEntriesFrom(ref input, _repeated_transform_codec);
            break;
          }
          case 34: {
            if (eulerAngles_ == null) {
              EulerAngles = new global::Mediapipe.ARCamera.Types.EulerAngles();
            }
            input.ReadMessage(EulerAngles);
            break;
          }
          case 40: {
            ImageResolutionWidth = input.ReadInt32();
            break;
          }
          case 48: {
            ImageResolutionHeight = input.ReadInt32();
            break;
          }
          case 58:
          case 61: {
            intrinsics_.AddEntriesFrom(ref input, _repeated_intrinsics_codec);
            break;
          }
          case 66:
          case 69: {
            projectionMatrix_.AddEntriesFrom(ref input, _repeated_projectionMatrix_codec);
            break;
          }
          case 74:
          case 77: {
            viewMatrix_.AddEntriesFrom(ref input, _repeated_viewMatrix_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ARCamera message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// The general quality of position tracking available when the camera captured
      /// a frame.
      /// </summary>
      public enum TrackingState {
        [pbr::OriginalName("UNDEFINED_TRACKING_STATE")] UndefinedTrackingState = 0,
        /// <summary>
        /// Camera position tracking is not available.
        /// </summary>
        [pbr::OriginalName("UNAVAILABLE")] Unavailable = 1,
        /// <summary>
        /// Tracking is available, but the quality of results is questionable.
        /// </summary>
        [pbr::OriginalName("LIMITED")] Limited = 2,
        /// <summary>
        /// Camera position tracking is providing optimal results.
        /// </summary>
        [pbr::OriginalName("NORMAL")] Normal = 3,
      }

      /// <summary>
      /// A possible diagnosis for limited position tracking quality as of when the
      /// frame was captured.
      /// </summary>
      public enum TrackingStateReason {
        [pbr::OriginalName("UNDEFINED_TRACKING_STATE_REASON")] UndefinedTrackingStateReason = 0,
        /// <summary>
        /// The current tracking state is not limited.
        /// </summary>
        [pbr::OriginalName("NONE")] None = 1,
        /// <summary>
        /// Not yet enough camera or motion data to provide tracking information.
        /// </summary>
        [pbr::OriginalName("INITIALIZING")] Initializing = 2,
        /// <summary>
        /// The device is moving too fast for accurate image-based position tracking.
        /// </summary>
        [pbr::OriginalName("EXCESSIVE_MOTION")] ExcessiveMotion = 3,
        /// <summary>
        /// Not enough distinguishable features for image-based position tracking.
        /// </summary>
        [pbr::OriginalName("INSUFFICIENT_FEATURES")] InsufficientFeatures = 4,
        /// <summary>
        /// Tracking is limited due to a relocalization in progress.
        /// </summary>
        [pbr::OriginalName("RELOCALIZING")] Relocalizing = 5,
      }

      /// <summary>
      /// The orientation of the camera, expressed as roll, pitch, and yaw values.
      /// </summary>
      public sealed partial class EulerAngles : pb::IMessage<EulerAngles>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<EulerAngles> _parser = new pb::MessageParser<EulerAngles>(() => new EulerAngles());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<EulerAngles> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.ARCamera.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EulerAngles() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EulerAngles(EulerAngles other) : this() {
          _hasBits0 = other._hasBits0;
          roll_ = other.roll_;
          pitch_ = other.pitch_;
          yaw_ = other.yaw_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EulerAngles Clone() {
          return new EulerAngles(this);
        }

        /// <summary>Field number for the "roll" field.</summary>
        public const int RollFieldNumber = 1;
        private readonly static float RollDefaultValue = 0F;

        private float roll_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Roll {
          get { if ((_hasBits0 & 1) != 0) { return roll_; } else { return RollDefaultValue; } }
          set {
            _hasBits0 |= 1;
            roll_ = value;
          }
        }
        /// <summary>Gets whether the "roll" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasRoll {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "roll" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearRoll() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "pitch" field.</summary>
        public const int PitchFieldNumber = 2;
        private readonly static float PitchDefaultValue = 0F;

        private float pitch_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Pitch {
          get { if ((_hasBits0 & 2) != 0) { return pitch_; } else { return PitchDefaultValue; } }
          set {
            _hasBits0 |= 2;
            pitch_ = value;
          }
        }
        /// <summary>Gets whether the "pitch" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasPitch {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "pitch" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearPitch() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "yaw" field.</summary>
        public const int YawFieldNumber = 3;
        private readonly static float YawDefaultValue = 0F;

        private float yaw_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Yaw {
          get { if ((_hasBits0 & 4) != 0) { return yaw_; } else { return YawDefaultValue; } }
          set {
            _hasBits0 |= 4;
            yaw_ = value;
          }
        }
        /// <summary>Gets whether the "yaw" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasYaw {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "yaw" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearYaw() {
          _hasBits0 &= ~4;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as EulerAngles);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(EulerAngles other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Roll, other.Roll)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Pitch, other.Pitch)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Yaw, other.Yaw)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasRoll) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Roll);
          if (HasPitch) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Pitch);
          if (HasYaw) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Yaw);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasRoll) {
            output.WriteRawTag(13);
            output.WriteFloat(Roll);
          }
          if (HasPitch) {
            output.WriteRawTag(21);
            output.WriteFloat(Pitch);
          }
          if (HasYaw) {
            output.WriteRawTag(29);
            output.WriteFloat(Yaw);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasRoll) {
            output.WriteRawTag(13);
            output.WriteFloat(Roll);
          }
          if (HasPitch) {
            output.WriteRawTag(21);
            output.WriteFloat(Pitch);
          }
          if (HasYaw) {
            output.WriteRawTag(29);
            output.WriteFloat(Yaw);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasRoll) {
            size += 1 + 4;
          }
          if (HasPitch) {
            size += 1 + 4;
          }
          if (HasYaw) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(EulerAngles other) {
          if (other == null) {
            return;
          }
          if (other.HasRoll) {
            Roll = other.Roll;
          }
          if (other.HasPitch) {
            Pitch = other.Pitch;
          }
          if (other.HasYaw) {
            Yaw = other.Yaw;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                Roll = input.ReadFloat();
                break;
              }
              case 21: {
                Pitch = input.ReadFloat();
                break;
              }
              case 29: {
                Yaw = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 13: {
                Roll = input.ReadFloat();
                break;
              }
              case 21: {
                Pitch = input.ReadFloat();
                break;
              }
              case 29: {
                Yaw = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Container for a 3D mesh describing face topology.
  /// </summary>
  public sealed partial class ARFaceGeometry : pb::IMessage<ARFaceGeometry>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ARFaceGeometry> _parser = new pb::MessageParser<ARFaceGeometry>(() => new ARFaceGeometry());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ARFaceGeometry> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.ARCaptureMetadataReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARFaceGeometry() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARFaceGeometry(ARFaceGeometry other) : this() {
      _hasBits0 = other._hasBits0;
      vertices_ = other.vertices_.Clone();
      vertexCount_ = other.vertexCount_;
      textureCoordinates_ = other.textureCoordinates_.Clone();
      textureCoordinateCount_ = other.textureCoordinateCount_;
      triangleIndices_ = other.triangleIndices_.Clone();
      triangleCount_ = other.triangleCount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARFaceGeometry Clone() {
      return new ARFaceGeometry(this);
    }

    /// <summary>Field number for the "vertices" field.</summary>
    public const int VerticesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Mediapipe.ARFaceGeometry.Types.Vertex> _repeated_vertices_codec
        = pb::FieldCodec.ForMessage(10, global::Mediapipe.ARFaceGeometry.Types.Vertex.Parser);
    private readonly pbc::RepeatedField<global::Mediapipe.ARFaceGeometry.Types.Vertex> vertices_ = new pbc::RepeatedField<global::Mediapipe.ARFaceGeometry.Types.Vertex>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Mediapipe.ARFaceGeometry.Types.Vertex> Vertices {
      get { return vertices_; }
    }

    /// <summary>Field number for the "vertex_count" field.</summary>
    public const int VertexCountFieldNumber = 2;
    private readonly static int VertexCountDefaultValue = 0;

    private int vertexCount_;
    /// <summary>
    /// The number of elements in the vertices list.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int VertexCount {
      get { if ((_hasBits0 & 1) != 0) { return vertexCount_; } else { return VertexCountDefaultValue; } }
      set {
        _hasBits0 |= 1;
        vertexCount_ = value;
      }
    }
    /// <summary>Gets whether the "vertex_count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVertexCount {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "vertex_count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVertexCount() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "texture_coordinates" field.</summary>
    public const int TextureCoordinatesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Mediapipe.ARFaceGeometry.Types.TextureCoordinate> _repeated_textureCoordinates_codec
        = pb::FieldCodec.ForMessage(26, global::Mediapipe.ARFaceGeometry.Types.TextureCoordinate.Parser);
    private readonly pbc::RepeatedField<global::Mediapipe.ARFaceGeometry.Types.TextureCoordinate> textureCoordinates_ = new pbc::RepeatedField<global::Mediapipe.ARFaceGeometry.Types.TextureCoordinate>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Mediapipe.ARFaceGeometry.Types.TextureCoordinate> TextureCoordinates {
      get { return textureCoordinates_; }
    }

    /// <summary>Field number for the "texture_coordinate_count" field.</summary>
    public const int TextureCoordinateCountFieldNumber = 4;
    private readonly static int TextureCoordinateCountDefaultValue = 0;

    private int textureCoordinateCount_;
    /// <summary>
    /// The number of elements in the texture_coordinates list.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TextureCoordinateCount {
      get { if ((_hasBits0 & 2) != 0) { return textureCoordinateCount_; } else { return TextureCoordinateCountDefaultValue; } }
      set {
        _hasBits0 |= 2;
        textureCoordinateCount_ = value;
      }
    }
    /// <summary>Gets whether the "texture_coordinate_count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTextureCoordinateCount {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "texture_coordinate_count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTextureCoordinateCount() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "triangle_indices" field.</summary>
    public const int TriangleIndicesFieldNumber = 5;
    private static readonly pb::FieldCodec<int> _repeated_triangleIndices_codec
        = pb::FieldCodec.ForInt32(42);
    private readonly pbc::RepeatedField<int> triangleIndices_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Each integer value in this ordered list represents an index into the
    /// vertices and texture_coordinates lists. Each set of three indices
    /// identifies the vertices comprising a single triangle in the mesh. Each set
    /// of three indices forms a triangle, so the number of indices in the
    /// triangle_indices buffer is three times the triangle_count value.
    /// See
    /// developer.apple.com/documentation/arkit/arfacegeometry/2928199-triangleindices
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> TriangleIndices {
      get { return triangleIndices_; }
    }

    /// <summary>Field number for the "triangle_count" field.</summary>
    public const int TriangleCountFieldNumber = 6;
    private readonly static int TriangleCountDefaultValue = 0;

    private int triangleCount_;
    /// <summary>
    /// The number of triangles described by the triangle_indices buffer.
    /// See
    /// developer.apple.com/documentation/arkit/arfacegeometry/2928207-trianglecount
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TriangleCount {
      get { if ((_hasBits0 & 4) != 0) { return triangleCount_; } else { return TriangleCountDefaultValue; } }
      set {
        _hasBits0 |= 4;
        triangleCount_ = value;
      }
    }
    /// <summary>Gets whether the "triangle_count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTriangleCount {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "triangle_count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTriangleCount() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ARFaceGeometry);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ARFaceGeometry other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!vertices_.Equals(other.vertices_)) return false;
      if (VertexCount != other.VertexCount) return false;
      if(!textureCoordinates_.Equals(other.textureCoordinates_)) return false;
      if (TextureCoordinateCount != other.TextureCoordinateCount) return false;
      if(!triangleIndices_.Equals(other.triangleIndices_)) return false;
      if (TriangleCount != other.TriangleCount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= vertices_.GetHashCode();
      if (HasVertexCount) hash ^= VertexCount.GetHashCode();
      hash ^= textureCoordinates_.GetHashCode();
      if (HasTextureCoordinateCount) hash ^= TextureCoordinateCount.GetHashCode();
      hash ^= triangleIndices_.GetHashCode();
      if (HasTriangleCount) hash ^= TriangleCount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      vertices_.WriteTo(output, _repeated_vertices_codec);
      if (HasVertexCount) {
        output.WriteRawTag(16);
        output.WriteInt32(VertexCount);
      }
      textureCoordinates_.WriteTo(output, _repeated_textureCoordinates_codec);
      if (HasTextureCoordinateCount) {
        output.WriteRawTag(32);
        output.WriteInt32(TextureCoordinateCount);
      }
      triangleIndices_.WriteTo(output, _repeated_triangleIndices_codec);
      if (HasTriangleCount) {
        output.WriteRawTag(48);
        output.WriteInt32(TriangleCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      vertices_.WriteTo(ref output, _repeated_vertices_codec);
      if (HasVertexCount) {
        output.WriteRawTag(16);
        output.WriteInt32(VertexCount);
      }
      textureCoordinates_.WriteTo(ref output, _repeated_textureCoordinates_codec);
      if (HasTextureCoordinateCount) {
        output.WriteRawTag(32);
        output.WriteInt32(TextureCoordinateCount);
      }
      triangleIndices_.WriteTo(ref output, _repeated_triangleIndices_codec);
      if (HasTriangleCount) {
        output.WriteRawTag(48);
        output.WriteInt32(TriangleCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += vertices_.CalculateSize(_repeated_vertices_codec);
      if (HasVertexCount) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(VertexCount);
      }
      size += textureCoordinates_.CalculateSize(_repeated_textureCoordinates_codec);
      if (HasTextureCoordinateCount) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TextureCoordinateCount);
      }
      size += triangleIndices_.CalculateSize(_repeated_triangleIndices_codec);
      if (HasTriangleCount) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TriangleCount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ARFaceGeometry other) {
      if (other == null) {
        return;
      }
      vertices_.Add(other.vertices_);
      if (other.HasVertexCount) {
        VertexCount = other.VertexCount;
      }
      textureCoordinates_.Add(other.textureCoordinates_);
      if (other.HasTextureCoordinateCount) {
        TextureCoordinateCount = other.TextureCoordinateCount;
      }
      triangleIndices_.Add(other.triangleIndices_);
      if (other.HasTriangleCount) {
        TriangleCount = other.TriangleCount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            vertices_.AddEntriesFrom(input, _repeated_vertices_codec);
            break;
          }
          case 16: {
            VertexCount = input.ReadInt32();
            break;
          }
          case 26: {
            textureCoordinates_.AddEntriesFrom(input, _repeated_textureCoordinates_codec);
            break;
          }
          case 32: {
            TextureCoordinateCount = input.ReadInt32();
            break;
          }
          case 42:
          case 40: {
            triangleIndices_.AddEntriesFrom(input, _repeated_triangleIndices_codec);
            break;
          }
          case 48: {
            TriangleCount = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            vertices_.AddEntriesFrom(ref input, _repeated_vertices_codec);
            break;
          }
          case 16: {
            VertexCount = input.ReadInt32();
            break;
          }
          case 26: {
            textureCoordinates_.AddEntriesFrom(ref input, _repeated_textureCoordinates_codec);
            break;
          }
          case 32: {
            TextureCoordinateCount = input.ReadInt32();
            break;
          }
          case 42:
          case 40: {
            triangleIndices_.AddEntriesFrom(ref input, _repeated_triangleIndices_codec);
            break;
          }
          case 48: {
            TriangleCount = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ARFaceGeometry message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Each vertex represents a 3D point in the face mesh, in the face coordinate
      /// space.
      /// See developer.apple.com/documentation/arkit/arfacegeometry/2928201-vertices
      /// for more information.
      /// </summary>
      public sealed partial class Vertex : pb::IMessage<Vertex>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Vertex> _parser = new pb::MessageParser<Vertex>(() => new Vertex());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Vertex> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.ARFaceGeometry.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Vertex() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Vertex(Vertex other) : this() {
          _hasBits0 = other._hasBits0;
          x_ = other.x_;
          y_ = other.y_;
          z_ = other.z_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Vertex Clone() {
          return new Vertex(this);
        }

        /// <summary>Field number for the "x" field.</summary>
        public const int XFieldNumber = 1;
        private readonly static float XDefaultValue = 0F;

        private float x_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float X {
          get { if ((_hasBits0 & 1) != 0) { return x_; } else { return XDefaultValue; } }
          set {
            _hasBits0 |= 1;
            x_ = value;
          }
        }
        /// <summary>Gets whether the "x" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasX {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "x" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearX() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "y" field.</summary>
        public const int YFieldNumber = 2;
        private readonly static float YDefaultValue = 0F;

        private float y_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Y {
          get { if ((_hasBits0 & 2) != 0) { return y_; } else { return YDefaultValue; } }
          set {
            _hasBits0 |= 2;
            y_ = value;
          }
        }
        /// <summary>Gets whether the "y" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasY {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "y" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearY() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "z" field.</summary>
        public const int ZFieldNumber = 3;
        private readonly static float ZDefaultValue = 0F;

        private float z_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Z {
          get { if ((_hasBits0 & 4) != 0) { return z_; } else { return ZDefaultValue; } }
          set {
            _hasBits0 |= 4;
            z_ = value;
          }
        }
        /// <summary>Gets whether the "z" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasZ {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "z" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearZ() {
          _hasBits0 &= ~4;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Vertex);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Vertex other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(X, other.X)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Y, other.Y)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Z, other.Z)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasX) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(X);
          if (HasY) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Y);
          if (HasZ) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Z);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasX) {
            output.WriteRawTag(13);
            output.WriteFloat(X);
          }
          if (HasY) {
            output.WriteRawTag(21);
            output.WriteFloat(Y);
          }
          if (HasZ) {
            output.WriteRawTag(29);
            output.WriteFloat(Z);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasX) {
            output.WriteRawTag(13);
            output.WriteFloat(X);
          }
          if (HasY) {
            output.WriteRawTag(21);
            output.WriteFloat(Y);
          }
          if (HasZ) {
            output.WriteRawTag(29);
            output.WriteFloat(Z);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasX) {
            size += 1 + 4;
          }
          if (HasY) {
            size += 1 + 4;
          }
          if (HasZ) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Vertex other) {
          if (other == null) {
            return;
          }
          if (other.HasX) {
            X = other.X;
          }
          if (other.HasY) {
            Y = other.Y;
          }
          if (other.HasZ) {
            Z = other.Z;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                X = input.ReadFloat();
                break;
              }
              case 21: {
                Y = input.ReadFloat();
                break;
              }
              case 29: {
                Z = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 13: {
                X = input.ReadFloat();
                break;
              }
              case 21: {
                Y = input.ReadFloat();
                break;
              }
              case 29: {
                Z = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Each texture coordinate represents UV texture coordinates for the vertex at
      /// the corresponding index in the vertices buffer.
      /// See
      /// developer.apple.com/documentation/arkit/arfacegeometry/2928203-texturecoordinates
      /// for more information.
      /// </summary>
      public sealed partial class TextureCoordinate : pb::IMessage<TextureCoordinate>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<TextureCoordinate> _parser = new pb::MessageParser<TextureCoordinate>(() => new TextureCoordinate());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<TextureCoordinate> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.ARFaceGeometry.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TextureCoordinate() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TextureCoordinate(TextureCoordinate other) : this() {
          _hasBits0 = other._hasBits0;
          u_ = other.u_;
          v_ = other.v_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TextureCoordinate Clone() {
          return new TextureCoordinate(this);
        }

        /// <summary>Field number for the "u" field.</summary>
        public const int UFieldNumber = 1;
        private readonly static float UDefaultValue = 0F;

        private float u_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float U {
          get { if ((_hasBits0 & 1) != 0) { return u_; } else { return UDefaultValue; } }
          set {
            _hasBits0 |= 1;
            u_ = value;
          }
        }
        /// <summary>Gets whether the "u" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasU {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "u" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearU() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "v" field.</summary>
        public const int VFieldNumber = 2;
        private readonly static float VDefaultValue = 0F;

        private float v_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float V {
          get { if ((_hasBits0 & 2) != 0) { return v_; } else { return VDefaultValue; } }
          set {
            _hasBits0 |= 2;
            v_ = value;
          }
        }
        /// <summary>Gets whether the "v" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasV {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "v" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearV() {
          _hasBits0 &= ~2;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as TextureCoordinate);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(TextureCoordinate other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(U, other.U)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(V, other.V)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasU) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(U);
          if (HasV) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(V);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasU) {
            output.WriteRawTag(13);
            output.WriteFloat(U);
          }
          if (HasV) {
            output.WriteRawTag(21);
            output.WriteFloat(V);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasU) {
            output.WriteRawTag(13);
            output.WriteFloat(U);
          }
          if (HasV) {
            output.WriteRawTag(21);
            output.WriteFloat(V);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasU) {
            size += 1 + 4;
          }
          if (HasV) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(TextureCoordinate other) {
          if (other == null) {
            return;
          }
          if (other.HasU) {
            U = other.U;
          }
          if (other.HasV) {
            V = other.V;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                U = input.ReadFloat();
                break;
              }
              case 21: {
                V = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 13: {
                U = input.ReadFloat();
                break;
              }
              case 21: {
                V = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Contains a list of blend shape entries wherein each item maps a specific
  /// blend shape location to its associated coefficient.
  /// </summary>
  public sealed partial class ARBlendShapeMap : pb::IMessage<ARBlendShapeMap>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ARBlendShapeMap> _parser = new pb::MessageParser<ARBlendShapeMap>(() => new ARBlendShapeMap());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ARBlendShapeMap> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.ARCaptureMetadataReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARBlendShapeMap() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARBlendShapeMap(ARBlendShapeMap other) : this() {
      entries_ = other.entries_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARBlendShapeMap Clone() {
      return new ARBlendShapeMap(this);
    }

    /// <summary>Field number for the "entries" field.</summary>
    public const int EntriesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Mediapipe.ARBlendShapeMap.Types.MapEntry> _repeated_entries_codec
        = pb::FieldCodec.ForMessage(10, global::Mediapipe.ARBlendShapeMap.Types.MapEntry.Parser);
    private readonly pbc::RepeatedField<global::Mediapipe.ARBlendShapeMap.Types.MapEntry> entries_ = new pbc::RepeatedField<global::Mediapipe.ARBlendShapeMap.Types.MapEntry>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Mediapipe.ARBlendShapeMap.Types.MapEntry> Entries {
      get { return entries_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ARBlendShapeMap);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ARBlendShapeMap other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!entries_.Equals(other.entries_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= entries_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      entries_.WriteTo(output, _repeated_entries_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      entries_.WriteTo(ref output, _repeated_entries_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += entries_.CalculateSize(_repeated_entries_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ARBlendShapeMap other) {
      if (other == null) {
        return;
      }
      entries_.Add(other.entries_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            entries_.AddEntriesFrom(input, _repeated_entries_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            entries_.AddEntriesFrom(ref input, _repeated_entries_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ARBlendShapeMap message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public sealed partial class MapEntry : pb::IMessage<MapEntry>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<MapEntry> _parser = new pb::MessageParser<MapEntry>(() => new MapEntry());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<MapEntry> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.ARBlendShapeMap.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public MapEntry() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public MapEntry(MapEntry other) : this() {
          _hasBits0 = other._hasBits0;
          blendShapeLocation_ = other.blendShapeLocation_;
          blendShapeCoefficient_ = other.blendShapeCoefficient_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public MapEntry Clone() {
          return new MapEntry(this);
        }

        /// <summary>Field number for the "blend_shape_location" field.</summary>
        public const int BlendShapeLocationFieldNumber = 1;
        private readonly static string BlendShapeLocationDefaultValue = "";

        private string blendShapeLocation_;
        /// <summary>
        /// Identifier for the specific facial feature.
        /// See developer.apple.com/documentation/arkit/arblendshapelocation for a
        /// complete list of identifiers.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string BlendShapeLocation {
          get { return blendShapeLocation_ ?? BlendShapeLocationDefaultValue; }
          set {
            blendShapeLocation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "blend_shape_location" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasBlendShapeLocation {
          get { return blendShapeLocation_ != null; }
        }
        /// <summary>Clears the value of the "blend_shape_location" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearBlendShapeLocation() {
          blendShapeLocation_ = null;
        }

        /// <summary>Field number for the "blend_shape_coefficient" field.</summary>
        public const int BlendShapeCoefficientFieldNumber = 2;
        private readonly static float BlendShapeCoefficientDefaultValue = 0F;

        private float blendShapeCoefficient_;
        /// <summary>
        /// Indicates the current position of the feature relative to its neutral
        /// configuration, ranging from 0.0 (neutral) to 1.0 (maximum movement).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float BlendShapeCoefficient {
          get { if ((_hasBits0 & 1) != 0) { return blendShapeCoefficient_; } else { return BlendShapeCoefficientDefaultValue; } }
          set {
            _hasBits0 |= 1;
            blendShapeCoefficient_ = value;
          }
        }
        /// <summary>Gets whether the "blend_shape_coefficient" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasBlendShapeCoefficient {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "blend_shape_coefficient" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearBlendShapeCoefficient() {
          _hasBits0 &= ~1;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as MapEntry);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(MapEntry other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (BlendShapeLocation != other.BlendShapeLocation) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(BlendShapeCoefficient, other.BlendShapeCoefficient)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasBlendShapeLocation) hash ^= BlendShapeLocation.GetHashCode();
          if (HasBlendShapeCoefficient) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(BlendShapeCoefficient);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasBlendShapeLocation) {
            output.WriteRawTag(10);
            output.WriteString(BlendShapeLocation);
          }
          if (HasBlendShapeCoefficient) {
            output.WriteRawTag(21);
            output.WriteFloat(BlendShapeCoefficient);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasBlendShapeLocation) {
            output.WriteRawTag(10);
            output.WriteString(BlendShapeLocation);
          }
          if (HasBlendShapeCoefficient) {
            output.WriteRawTag(21);
            output.WriteFloat(BlendShapeCoefficient);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasBlendShapeLocation) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(BlendShapeLocation);
          }
          if (HasBlendShapeCoefficient) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(MapEntry other) {
          if (other == null) {
            return;
          }
          if (other.HasBlendShapeLocation) {
            BlendShapeLocation = other.BlendShapeLocation;
          }
          if (other.HasBlendShapeCoefficient) {
            BlendShapeCoefficient = other.BlendShapeCoefficient;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                BlendShapeLocation = input.ReadString();
                break;
              }
              case 21: {
                BlendShapeCoefficient = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                BlendShapeLocation = input.ReadString();
                break;
              }
              case 21: {
                BlendShapeCoefficient = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Information about the pose, topology, and expression of a detected face.
  /// See developer.apple.com/documentation/arkit/arfaceanchor for more info.
  /// </summary>
  public sealed partial class ARFaceAnchor : pb::IMessage<ARFaceAnchor>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ARFaceAnchor> _parser = new pb::MessageParser<ARFaceAnchor>(() => new ARFaceAnchor());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ARFaceAnchor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.ARCaptureMetadataReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARFaceAnchor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARFaceAnchor(ARFaceAnchor other) : this() {
      _hasBits0 = other._hasBits0;
      geometry_ = other.geometry_ != null ? other.geometry_.Clone() : null;
      blendShapes_ = other.blendShapes_ != null ? other.blendShapes_.Clone() : null;
      transform_ = other.transform_.Clone();
      isTracked_ = other.isTracked_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARFaceAnchor Clone() {
      return new ARFaceAnchor(this);
    }

    /// <summary>Field number for the "geometry" field.</summary>
    public const int GeometryFieldNumber = 1;
    private global::Mediapipe.ARFaceGeometry geometry_;
    /// <summary>
    /// A coarse triangle mesh representing the topology of the detected face.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ARFaceGeometry Geometry {
      get { return geometry_; }
      set {
        geometry_ = value;
      }
    }

    /// <summary>Field number for the "blend_shapes" field.</summary>
    public const int BlendShapesFieldNumber = 2;
    private global::Mediapipe.ARBlendShapeMap blendShapes_;
    /// <summary>
    /// A map of named coefficients representing the detected facial expression in
    /// terms of the movement of specific facial features.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ARBlendShapeMap BlendShapes {
      get { return blendShapes_; }
      set {
        blendShapes_ = value;
      }
    }

    /// <summary>Field number for the "transform" field.</summary>
    public const int TransformFieldNumber = 3;
    private static readonly pb::FieldCodec<float> _repeated_transform_codec
        = pb::FieldCodec.ForFloat(29);
    private readonly pbc::RepeatedField<float> transform_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// 4x4 row-major matrix encoding the position, orientation, and scale of the
    /// anchor relative to the world coordinate space.
    /// See
    /// https://developer.apple.com/documentation/arkit/aranchor/2867981-transform?language=objc
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<float> Transform {
      get { return transform_; }
    }

    /// <summary>Field number for the "is_tracked" field.</summary>
    public const int IsTrackedFieldNumber = 4;
    private readonly static bool IsTrackedDefaultValue = false;

    private bool isTracked_;
    /// <summary>
    /// Indicates whether the anchor's transform is valid. Frames that have a face
    /// anchor with this value set to NO should probably be ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsTracked {
      get { if ((_hasBits0 & 1) != 0) { return isTracked_; } else { return IsTrackedDefaultValue; } }
      set {
        _hasBits0 |= 1;
        isTracked_ = value;
      }
    }
    /// <summary>Gets whether the "is_tracked" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIsTracked {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "is_tracked" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIsTracked() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ARFaceAnchor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ARFaceAnchor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Geometry, other.Geometry)) return false;
      if (!object.Equals(BlendShapes, other.BlendShapes)) return false;
      if(!transform_.Equals(other.transform_)) return false;
      if (IsTracked != other.IsTracked) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (geometry_ != null) hash ^= Geometry.GetHashCode();
      if (blendShapes_ != null) hash ^= BlendShapes.GetHashCode();
      hash ^= transform_.GetHashCode();
      if (HasIsTracked) hash ^= IsTracked.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (geometry_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Geometry);
      }
      if (blendShapes_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(BlendShapes);
      }
      transform_.WriteTo(output, _repeated_transform_codec);
      if (HasIsTracked) {
        output.WriteRawTag(32);
        output.WriteBool(IsTracked);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (geometry_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Geometry);
      }
      if (blendShapes_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(BlendShapes);
      }
      transform_.WriteTo(ref output, _repeated_transform_codec);
      if (HasIsTracked) {
        output.WriteRawTag(32);
        output.WriteBool(IsTracked);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (geometry_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Geometry);
      }
      if (blendShapes_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BlendShapes);
      }
      size += transform_.CalculateSize(_repeated_transform_codec);
      if (HasIsTracked) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ARFaceAnchor other) {
      if (other == null) {
        return;
      }
      if (other.geometry_ != null) {
        if (geometry_ == null) {
          Geometry = new global::Mediapipe.ARFaceGeometry();
        }
        Geometry.MergeFrom(other.Geometry);
      }
      if (other.blendShapes_ != null) {
        if (blendShapes_ == null) {
          BlendShapes = new global::Mediapipe.ARBlendShapeMap();
        }
        BlendShapes.MergeFrom(other.BlendShapes);
      }
      transform_.Add(other.transform_);
      if (other.HasIsTracked) {
        IsTracked = other.IsTracked;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (geometry_ == null) {
              Geometry = new global::Mediapipe.ARFaceGeometry();
            }
            input.ReadMessage(Geometry);
            break;
          }
          case 18: {
            if (blendShapes_ == null) {
              BlendShapes = new global::Mediapipe.ARBlendShapeMap();
            }
            input.ReadMessage(BlendShapes);
            break;
          }
          case 26:
          case 29: {
            transform_.AddEntriesFrom(input, _repeated_transform_codec);
            break;
          }
          case 32: {
            IsTracked = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (geometry_ == null) {
              Geometry = new global::Mediapipe.ARFaceGeometry();
            }
            input.ReadMessage(Geometry);
            break;
          }
          case 18: {
            if (blendShapes_ == null) {
              BlendShapes = new global::Mediapipe.ARBlendShapeMap();
            }
            input.ReadMessage(BlendShapes);
            break;
          }
          case 26:
          case 29: {
            transform_.AddEntriesFrom(ref input, _repeated_transform_codec);
            break;
          }
          case 32: {
            IsTracked = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Container for a 3D mesh.
  /// </summary>
  public sealed partial class ARPlaneGeometry : pb::IMessage<ARPlaneGeometry>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ARPlaneGeometry> _parser = new pb::MessageParser<ARPlaneGeometry>(() => new ARPlaneGeometry());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ARPlaneGeometry> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.ARCaptureMetadataReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARPlaneGeometry() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARPlaneGeometry(ARPlaneGeometry other) : this() {
      _hasBits0 = other._hasBits0;
      vertices_ = other.vertices_.Clone();
      vertexCount_ = other.vertexCount_;
      textureCoordinates_ = other.textureCoordinates_.Clone();
      textureCoordinateCount_ = other.textureCoordinateCount_;
      triangleIndices_ = other.triangleIndices_.Clone();
      triangleCount_ = other.triangleCount_;
      boundaryVertices_ = other.boundaryVertices_.Clone();
      boundaryVertexCount_ = other.boundaryVertexCount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARPlaneGeometry Clone() {
      return new ARPlaneGeometry(this);
    }

    /// <summary>Field number for the "vertices" field.</summary>
    public const int VerticesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Mediapipe.ARPlaneGeometry.Types.Vertex> _repeated_vertices_codec
        = pb::FieldCodec.ForMessage(10, global::Mediapipe.ARPlaneGeometry.Types.Vertex.Parser);
    private readonly pbc::RepeatedField<global::Mediapipe.ARPlaneGeometry.Types.Vertex> vertices_ = new pbc::RepeatedField<global::Mediapipe.ARPlaneGeometry.Types.Vertex>();
    /// <summary>
    /// A buffer of vertex positions for each point in the plane mesh.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Mediapipe.ARPlaneGeometry.Types.Vertex> Vertices {
      get { return vertices_; }
    }

    /// <summary>Field number for the "vertex_count" field.</summary>
    public const int VertexCountFieldNumber = 2;
    private readonly static int VertexCountDefaultValue = 0;

    private int vertexCount_;
    /// <summary>
    /// The number of elements in the vertices buffer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int VertexCount {
      get { if ((_hasBits0 & 1) != 0) { return vertexCount_; } else { return VertexCountDefaultValue; } }
      set {
        _hasBits0 |= 1;
        vertexCount_ = value;
      }
    }
    /// <summary>Gets whether the "vertex_count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVertexCount {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "vertex_count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVertexCount() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "texture_coordinates" field.</summary>
    public const int TextureCoordinatesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Mediapipe.ARPlaneGeometry.Types.TextureCoordinate> _repeated_textureCoordinates_codec
        = pb::FieldCodec.ForMessage(26, global::Mediapipe.ARPlaneGeometry.Types.TextureCoordinate.Parser);
    private readonly pbc::RepeatedField<global::Mediapipe.ARPlaneGeometry.Types.TextureCoordinate> textureCoordinates_ = new pbc::RepeatedField<global::Mediapipe.ARPlaneGeometry.Types.TextureCoordinate>();
    /// <summary>
    /// A buffer of texture coordinate values for each point in the plane mesh.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Mediapipe.ARPlaneGeometry.Types.TextureCoordinate> TextureCoordinates {
      get { return textureCoordinates_; }
    }

    /// <summary>Field number for the "texture_coordinate_count" field.</summary>
    public const int TextureCoordinateCountFieldNumber = 4;
    private readonly static int TextureCoordinateCountDefaultValue = 0;

    private int textureCoordinateCount_;
    /// <summary>
    /// The number of elements in the texture_coordinates buffer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TextureCoordinateCount {
      get { if ((_hasBits0 & 2) != 0) { return textureCoordinateCount_; } else { return TextureCoordinateCountDefaultValue; } }
      set {
        _hasBits0 |= 2;
        textureCoordinateCount_ = value;
      }
    }
    /// <summary>Gets whether the "texture_coordinate_count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTextureCoordinateCount {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "texture_coordinate_count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTextureCoordinateCount() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "triangle_indices" field.</summary>
    public const int TriangleIndicesFieldNumber = 5;
    private static readonly pb::FieldCodec<int> _repeated_triangleIndices_codec
        = pb::FieldCodec.ForInt32(42);
    private readonly pbc::RepeatedField<int> triangleIndices_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Each integer value in this ordered list represents an index into the
    /// vertices and texture_coordinates lists. Each set of three indices
    /// identifies the vertices comprising a single triangle in the mesh. Each set
    /// of three indices forms a triangle, so the number of indices in the
    /// triangle_indices buffer is three times the triangle_count value.
    /// See
    /// https://developer.apple.com/documentation/arkit/arplanegeometry/2941051-triangleindices
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> TriangleIndices {
      get { return triangleIndices_; }
    }

    /// <summary>Field number for the "triangle_count" field.</summary>
    public const int TriangleCountFieldNumber = 6;
    private readonly static int TriangleCountDefaultValue = 0;

    private int triangleCount_;
    /// <summary>
    /// Each set of three indices forms a triangle, so the number of indices in the
    /// triangle_indices buffer is three times the triangle_count value.
    /// See
    /// https://developer.apple.com/documentation/arkit/arplanegeometry/2941058-trianglecount
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TriangleCount {
      get { if ((_hasBits0 & 4) != 0) { return triangleCount_; } else { return TriangleCountDefaultValue; } }
      set {
        _hasBits0 |= 4;
        triangleCount_ = value;
      }
    }
    /// <summary>Gets whether the "triangle_count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTriangleCount {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "triangle_count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTriangleCount() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "boundary_vertices" field.</summary>
    public const int BoundaryVerticesFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Mediapipe.ARPlaneGeometry.Types.Vertex> _repeated_boundaryVertices_codec
        = pb::FieldCodec.ForMessage(58, global::Mediapipe.ARPlaneGeometry.Types.Vertex.Parser);
    private readonly pbc::RepeatedField<global::Mediapipe.ARPlaneGeometry.Types.Vertex> boundaryVertices_ = new pbc::RepeatedField<global::Mediapipe.ARPlaneGeometry.Types.Vertex>();
    /// <summary>
    /// Each value in this buffer represents the position of a vertex along the
    /// boundary polygon of the estimated plane. The owning plane anchor's
    /// transform matrix defines the coordinate system for these points.
    /// See
    /// https://developer.apple.com/documentation/arkit/arplanegeometry/2941052-boundaryvertices
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Mediapipe.ARPlaneGeometry.Types.Vertex> BoundaryVertices {
      get { return boundaryVertices_; }
    }

    /// <summary>Field number for the "boundary_vertex_count" field.</summary>
    public const int BoundaryVertexCountFieldNumber = 8;
    private readonly static int BoundaryVertexCountDefaultValue = 0;

    private int boundaryVertexCount_;
    /// <summary>
    /// The number of elements in the boundary_vertices buffer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int BoundaryVertexCount {
      get { if ((_hasBits0 & 8) != 0) { return boundaryVertexCount_; } else { return BoundaryVertexCountDefaultValue; } }
      set {
        _hasBits0 |= 8;
        boundaryVertexCount_ = value;
      }
    }
    /// <summary>Gets whether the "boundary_vertex_count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBoundaryVertexCount {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "boundary_vertex_count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBoundaryVertexCount() {
      _hasBits0 &= ~8;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ARPlaneGeometry);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ARPlaneGeometry other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!vertices_.Equals(other.vertices_)) return false;
      if (VertexCount != other.VertexCount) return false;
      if(!textureCoordinates_.Equals(other.textureCoordinates_)) return false;
      if (TextureCoordinateCount != other.TextureCoordinateCount) return false;
      if(!triangleIndices_.Equals(other.triangleIndices_)) return false;
      if (TriangleCount != other.TriangleCount) return false;
      if(!boundaryVertices_.Equals(other.boundaryVertices_)) return false;
      if (BoundaryVertexCount != other.BoundaryVertexCount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= vertices_.GetHashCode();
      if (HasVertexCount) hash ^= VertexCount.GetHashCode();
      hash ^= textureCoordinates_.GetHashCode();
      if (HasTextureCoordinateCount) hash ^= TextureCoordinateCount.GetHashCode();
      hash ^= triangleIndices_.GetHashCode();
      if (HasTriangleCount) hash ^= TriangleCount.GetHashCode();
      hash ^= boundaryVertices_.GetHashCode();
      if (HasBoundaryVertexCount) hash ^= BoundaryVertexCount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      vertices_.WriteTo(output, _repeated_vertices_codec);
      if (HasVertexCount) {
        output.WriteRawTag(16);
        output.WriteInt32(VertexCount);
      }
      textureCoordinates_.WriteTo(output, _repeated_textureCoordinates_codec);
      if (HasTextureCoordinateCount) {
        output.WriteRawTag(32);
        output.WriteInt32(TextureCoordinateCount);
      }
      triangleIndices_.WriteTo(output, _repeated_triangleIndices_codec);
      if (HasTriangleCount) {
        output.WriteRawTag(48);
        output.WriteInt32(TriangleCount);
      }
      boundaryVertices_.WriteTo(output, _repeated_boundaryVertices_codec);
      if (HasBoundaryVertexCount) {
        output.WriteRawTag(64);
        output.WriteInt32(BoundaryVertexCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      vertices_.WriteTo(ref output, _repeated_vertices_codec);
      if (HasVertexCount) {
        output.WriteRawTag(16);
        output.WriteInt32(VertexCount);
      }
      textureCoordinates_.WriteTo(ref output, _repeated_textureCoordinates_codec);
      if (HasTextureCoordinateCount) {
        output.WriteRawTag(32);
        output.WriteInt32(TextureCoordinateCount);
      }
      triangleIndices_.WriteTo(ref output, _repeated_triangleIndices_codec);
      if (HasTriangleCount) {
        output.WriteRawTag(48);
        output.WriteInt32(TriangleCount);
      }
      boundaryVertices_.WriteTo(ref output, _repeated_boundaryVertices_codec);
      if (HasBoundaryVertexCount) {
        output.WriteRawTag(64);
        output.WriteInt32(BoundaryVertexCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += vertices_.CalculateSize(_repeated_vertices_codec);
      if (HasVertexCount) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(VertexCount);
      }
      size += textureCoordinates_.CalculateSize(_repeated_textureCoordinates_codec);
      if (HasTextureCoordinateCount) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TextureCoordinateCount);
      }
      size += triangleIndices_.CalculateSize(_repeated_triangleIndices_codec);
      if (HasTriangleCount) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TriangleCount);
      }
      size += boundaryVertices_.CalculateSize(_repeated_boundaryVertices_codec);
      if (HasBoundaryVertexCount) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(BoundaryVertexCount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ARPlaneGeometry other) {
      if (other == null) {
        return;
      }
      vertices_.Add(other.vertices_);
      if (other.HasVertexCount) {
        VertexCount = other.VertexCount;
      }
      textureCoordinates_.Add(other.textureCoordinates_);
      if (other.HasTextureCoordinateCount) {
        TextureCoordinateCount = other.TextureCoordinateCount;
      }
      triangleIndices_.Add(other.triangleIndices_);
      if (other.HasTriangleCount) {
        TriangleCount = other.TriangleCount;
      }
      boundaryVertices_.Add(other.boundaryVertices_);
      if (other.HasBoundaryVertexCount) {
        BoundaryVertexCount = other.BoundaryVertexCount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            vertices_.AddEntriesFrom(input, _repeated_vertices_codec);
            break;
          }
          case 16: {
            VertexCount = input.ReadInt32();
            break;
          }
          case 26: {
            textureCoordinates_.AddEntriesFrom(input, _repeated_textureCoordinates_codec);
            break;
          }
          case 32: {
            TextureCoordinateCount = input.ReadInt32();
            break;
          }
          case 42:
          case 40: {
            triangleIndices_.AddEntriesFrom(input, _repeated_triangleIndices_codec);
            break;
          }
          case 48: {
            TriangleCount = input.ReadInt32();
            break;
          }
          case 58: {
            boundaryVertices_.AddEntriesFrom(input, _repeated_boundaryVertices_codec);
            break;
          }
          case 64: {
            BoundaryVertexCount = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            vertices_.AddEntriesFrom(ref input, _repeated_vertices_codec);
            break;
          }
          case 16: {
            VertexCount = input.ReadInt32();
            break;
          }
          case 26: {
            textureCoordinates_.AddEntriesFrom(ref input, _repeated_textureCoordinates_codec);
            break;
          }
          case 32: {
            TextureCoordinateCount = input.ReadInt32();
            break;
          }
          case 42:
          case 40: {
            triangleIndices_.AddEntriesFrom(ref input, _repeated_triangleIndices_codec);
            break;
          }
          case 48: {
            TriangleCount = input.ReadInt32();
            break;
          }
          case 58: {
            boundaryVertices_.AddEntriesFrom(ref input, _repeated_boundaryVertices_codec);
            break;
          }
          case 64: {
            BoundaryVertexCount = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ARPlaneGeometry message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public sealed partial class Vertex : pb::IMessage<Vertex>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Vertex> _parser = new pb::MessageParser<Vertex>(() => new Vertex());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Vertex> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.ARPlaneGeometry.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Vertex() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Vertex(Vertex other) : this() {
          _hasBits0 = other._hasBits0;
          x_ = other.x_;
          y_ = other.y_;
          z_ = other.z_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Vertex Clone() {
          return new Vertex(this);
        }

        /// <summary>Field number for the "x" field.</summary>
        public const int XFieldNumber = 1;
        private readonly static float XDefaultValue = 0F;

        private float x_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float X {
          get { if ((_hasBits0 & 1) != 0) { return x_; } else { return XDefaultValue; } }
          set {
            _hasBits0 |= 1;
            x_ = value;
          }
        }
        /// <summary>Gets whether the "x" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasX {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "x" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearX() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "y" field.</summary>
        public const int YFieldNumber = 2;
        private readonly static float YDefaultValue = 0F;

        private float y_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Y {
          get { if ((_hasBits0 & 2) != 0) { return y_; } else { return YDefaultValue; } }
          set {
            _hasBits0 |= 2;
            y_ = value;
          }
        }
        /// <summary>Gets whether the "y" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasY {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "y" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearY() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "z" field.</summary>
        public const int ZFieldNumber = 3;
        private readonly static float ZDefaultValue = 0F;

        private float z_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Z {
          get { if ((_hasBits0 & 4) != 0) { return z_; } else { return ZDefaultValue; } }
          set {
            _hasBits0 |= 4;
            z_ = value;
          }
        }
        /// <summary>Gets whether the "z" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasZ {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "z" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearZ() {
          _hasBits0 &= ~4;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Vertex);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Vertex other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(X, other.X)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Y, other.Y)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Z, other.Z)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasX) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(X);
          if (HasY) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Y);
          if (HasZ) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Z);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasX) {
            output.WriteRawTag(13);
            output.WriteFloat(X);
          }
          if (HasY) {
            output.WriteRawTag(21);
            output.WriteFloat(Y);
          }
          if (HasZ) {
            output.WriteRawTag(29);
            output.WriteFloat(Z);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasX) {
            output.WriteRawTag(13);
            output.WriteFloat(X);
          }
          if (HasY) {
            output.WriteRawTag(21);
            output.WriteFloat(Y);
          }
          if (HasZ) {
            output.WriteRawTag(29);
            output.WriteFloat(Z);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasX) {
            size += 1 + 4;
          }
          if (HasY) {
            size += 1 + 4;
          }
          if (HasZ) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Vertex other) {
          if (other == null) {
            return;
          }
          if (other.HasX) {
            X = other.X;
          }
          if (other.HasY) {
            Y = other.Y;
          }
          if (other.HasZ) {
            Z = other.Z;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                X = input.ReadFloat();
                break;
              }
              case 21: {
                Y = input.ReadFloat();
                break;
              }
              case 29: {
                Z = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 13: {
                X = input.ReadFloat();
                break;
              }
              case 21: {
                Y = input.ReadFloat();
                break;
              }
              case 29: {
                Z = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Each texture coordinate represents UV texture coordinates for the vertex at
      /// the corresponding index in the vertices buffer.
      /// See
      /// https://developer.apple.com/documentation/arkit/arfacegeometry/2928203-texturecoordinates
      /// for more information.
      /// </summary>
      public sealed partial class TextureCoordinate : pb::IMessage<TextureCoordinate>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<TextureCoordinate> _parser = new pb::MessageParser<TextureCoordinate>(() => new TextureCoordinate());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<TextureCoordinate> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.ARPlaneGeometry.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TextureCoordinate() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TextureCoordinate(TextureCoordinate other) : this() {
          _hasBits0 = other._hasBits0;
          u_ = other.u_;
          v_ = other.v_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TextureCoordinate Clone() {
          return new TextureCoordinate(this);
        }

        /// <summary>Field number for the "u" field.</summary>
        public const int UFieldNumber = 1;
        private readonly static float UDefaultValue = 0F;

        private float u_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float U {
          get { if ((_hasBits0 & 1) != 0) { return u_; } else { return UDefaultValue; } }
          set {
            _hasBits0 |= 1;
            u_ = value;
          }
        }
        /// <summary>Gets whether the "u" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasU {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "u" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearU() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "v" field.</summary>
        public const int VFieldNumber = 2;
        private readonly static float VDefaultValue = 0F;

        private float v_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float V {
          get { if ((_hasBits0 & 2) != 0) { return v_; } else { return VDefaultValue; } }
          set {
            _hasBits0 |= 2;
            v_ = value;
          }
        }
        /// <summary>Gets whether the "v" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasV {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "v" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearV() {
          _hasBits0 &= ~2;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as TextureCoordinate);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(TextureCoordinate other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(U, other.U)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(V, other.V)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasU) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(U);
          if (HasV) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(V);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasU) {
            output.WriteRawTag(13);
            output.WriteFloat(U);
          }
          if (HasV) {
            output.WriteRawTag(21);
            output.WriteFloat(V);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasU) {
            output.WriteRawTag(13);
            output.WriteFloat(U);
          }
          if (HasV) {
            output.WriteRawTag(21);
            output.WriteFloat(V);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasU) {
            size += 1 + 4;
          }
          if (HasV) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(TextureCoordinate other) {
          if (other == null) {
            return;
          }
          if (other.HasU) {
            U = other.U;
          }
          if (other.HasV) {
            V = other.V;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                U = input.ReadFloat();
                break;
              }
              case 21: {
                V = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 13: {
                U = input.ReadFloat();
                break;
              }
              case 21: {
                V = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Information about the position and orientation of a real-world flat surface.
  /// See https://developer.apple.com/documentation/arkit/arplaneanchor for more
  /// information.
  /// </summary>
  public sealed partial class ARPlaneAnchor : pb::IMessage<ARPlaneAnchor>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ARPlaneAnchor> _parser = new pb::MessageParser<ARPlaneAnchor>(() => new ARPlaneAnchor());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ARPlaneAnchor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.ARCaptureMetadataReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARPlaneAnchor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARPlaneAnchor(ARPlaneAnchor other) : this() {
      _hasBits0 = other._hasBits0;
      identifier_ = other.identifier_;
      transform_ = other.transform_.Clone();
      alignment_ = other.alignment_;
      geometry_ = other.geometry_ != null ? other.geometry_.Clone() : null;
      center_ = other.center_ != null ? other.center_.Clone() : null;
      extent_ = other.extent_ != null ? other.extent_.Clone() : null;
      classificationSupported_ = other.classificationSupported_;
      classification_ = other.classification_;
      classificationStatus_ = other.classificationStatus_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARPlaneAnchor Clone() {
      return new ARPlaneAnchor(this);
    }

    /// <summary>Field number for the "identifier" field.</summary>
    public const int IdentifierFieldNumber = 1;
    private readonly static string IdentifierDefaultValue = "";

    private string identifier_;
    /// <summary>
    /// The ID of the plane.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Identifier {
      get { return identifier_ ?? IdentifierDefaultValue; }
      set {
        identifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "identifier" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIdentifier {
      get { return identifier_ != null; }
    }
    /// <summary>Clears the value of the "identifier" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIdentifier() {
      identifier_ = null;
    }

    /// <summary>Field number for the "transform" field.</summary>
    public const int TransformFieldNumber = 2;
    private static readonly pb::FieldCodec<float> _repeated_transform_codec
        = pb::FieldCodec.ForFloat(21);
    private readonly pbc::RepeatedField<float> transform_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// 4x4 row-major matrix encoding the position, orientation, and scale of the
    /// anchor relative to the world coordinate space.
    /// See
    /// https://developer.apple.com/documentation/arkit/aranchor/2867981-transform
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<float> Transform {
      get { return transform_; }
    }

    /// <summary>Field number for the "alignment" field.</summary>
    public const int AlignmentFieldNumber = 3;
    private readonly static global::Mediapipe.ARPlaneAnchor.Types.Alignment AlignmentDefaultValue = global::Mediapipe.ARPlaneAnchor.Types.Alignment.Undefined;

    private global::Mediapipe.ARPlaneAnchor.Types.Alignment alignment_;
    /// <summary>
    /// The general orientation of the detected plane with respect to gravity.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ARPlaneAnchor.Types.Alignment Alignment {
      get { if ((_hasBits0 & 1) != 0) { return alignment_; } else { return AlignmentDefaultValue; } }
      set {
        _hasBits0 |= 1;
        alignment_ = value;
      }
    }
    /// <summary>Gets whether the "alignment" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAlignment {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "alignment" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAlignment() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "geometry" field.</summary>
    public const int GeometryFieldNumber = 4;
    private global::Mediapipe.ARPlaneGeometry geometry_;
    /// <summary>
    /// A coarse triangle mesh representing the general shape of the detected
    /// plane.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ARPlaneGeometry Geometry {
      get { return geometry_; }
      set {
        geometry_ = value;
      }
    }

    /// <summary>Field number for the "center" field.</summary>
    public const int CenterFieldNumber = 5;
    private global::Mediapipe.ARPlaneAnchor.Types.PlaneVector center_;
    /// <summary>
    /// The center point of the plane relative to its anchor position.
    /// Although the type of this property is a 3D vector, a plane anchor is always
    /// two-dimensional, and is always positioned in only the x and z directions
    /// relative to its transform position. (That is, the y-component of this
    /// vector is always zero.)
    /// See
    /// https://developer.apple.com/documentation/arkit/arplaneanchor/2882056-center
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ARPlaneAnchor.Types.PlaneVector Center {
      get { return center_; }
      set {
        center_ = value;
      }
    }

    /// <summary>Field number for the "extent" field.</summary>
    public const int ExtentFieldNumber = 6;
    private global::Mediapipe.ARPlaneAnchor.Types.PlaneVector extent_;
    /// <summary>
    /// The estimated width and length of the detected plane.
    /// See
    /// https://developer.apple.com/documentation/arkit/arplaneanchor/2882055-extent
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ARPlaneAnchor.Types.PlaneVector Extent {
      get { return extent_; }
      set {
        extent_ = value;
      }
    }

    /// <summary>Field number for the "classification_supported" field.</summary>
    public const int ClassificationSupportedFieldNumber = 7;
    private readonly static bool ClassificationSupportedDefaultValue = false;

    private bool classificationSupported_;
    /// <summary>
    /// A Boolean value that indicates whether plane classification is available on
    /// the current device. On devices without plane classification support, all
    /// plane anchors report a classification value of NONE
    /// and a classification_status value of UNAVAILABLE.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ClassificationSupported {
      get { if ((_hasBits0 & 2) != 0) { return classificationSupported_; } else { return ClassificationSupportedDefaultValue; } }
      set {
        _hasBits0 |= 2;
        classificationSupported_ = value;
      }
    }
    /// <summary>Gets whether the "classification_supported" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasClassificationSupported {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "classification_supported" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearClassificationSupported() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "classification" field.</summary>
    public const int ClassificationFieldNumber = 8;
    private readonly static global::Mediapipe.ARPlaneAnchor.Types.PlaneClassification ClassificationDefaultValue = global::Mediapipe.ARPlaneAnchor.Types.PlaneClassification.None;

    private global::Mediapipe.ARPlaneAnchor.Types.PlaneClassification classification_;
    /// <summary>
    /// A general characterization of what kind of real-world surface the plane
    /// anchor represents.
    /// See
    /// https://developer.apple.com/documentation/arkit/arplaneanchor/2990936-classification
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ARPlaneAnchor.Types.PlaneClassification Classification {
      get { if ((_hasBits0 & 4) != 0) { return classification_; } else { return ClassificationDefaultValue; } }
      set {
        _hasBits0 |= 4;
        classification_ = value;
      }
    }
    /// <summary>Gets whether the "classification" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasClassification {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "classification" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearClassification() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "classification_status" field.</summary>
    public const int ClassificationStatusFieldNumber = 9;
    private readonly static global::Mediapipe.ARPlaneAnchor.Types.PlaneClassificationStatus ClassificationStatusDefaultValue = global::Mediapipe.ARPlaneAnchor.Types.PlaneClassificationStatus.Unknown;

    private global::Mediapipe.ARPlaneAnchor.Types.PlaneClassificationStatus classificationStatus_;
    /// <summary>
    /// The current state of ARKit's process for classifying the plane anchor.
    /// When this property's value is KNOWN, the classification property represents
    /// ARKit's characterization of the real-world surface corresponding to the
    /// plane anchor.
    /// See
    /// https://developer.apple.com/documentation/arkit/arplaneanchor/2990937-classificationstatus
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ARPlaneAnchor.Types.PlaneClassificationStatus ClassificationStatus {
      get { if ((_hasBits0 & 8) != 0) { return classificationStatus_; } else { return ClassificationStatusDefaultValue; } }
      set {
        _hasBits0 |= 8;
        classificationStatus_ = value;
      }
    }
    /// <summary>Gets whether the "classification_status" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasClassificationStatus {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "classification_status" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearClassificationStatus() {
      _hasBits0 &= ~8;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ARPlaneAnchor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ARPlaneAnchor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Identifier != other.Identifier) return false;
      if(!transform_.Equals(other.transform_)) return false;
      if (Alignment != other.Alignment) return false;
      if (!object.Equals(Geometry, other.Geometry)) return false;
      if (!object.Equals(Center, other.Center)) return false;
      if (!object.Equals(Extent, other.Extent)) return false;
      if (ClassificationSupported != other.ClassificationSupported) return false;
      if (Classification != other.Classification) return false;
      if (ClassificationStatus != other.ClassificationStatus) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasIdentifier) hash ^= Identifier.GetHashCode();
      hash ^= transform_.GetHashCode();
      if (HasAlignment) hash ^= Alignment.GetHashCode();
      if (geometry_ != null) hash ^= Geometry.GetHashCode();
      if (center_ != null) hash ^= Center.GetHashCode();
      if (extent_ != null) hash ^= Extent.GetHashCode();
      if (HasClassificationSupported) hash ^= ClassificationSupported.GetHashCode();
      if (HasClassification) hash ^= Classification.GetHashCode();
      if (HasClassificationStatus) hash ^= ClassificationStatus.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasIdentifier) {
        output.WriteRawTag(10);
        output.WriteString(Identifier);
      }
      transform_.WriteTo(output, _repeated_transform_codec);
      if (HasAlignment) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Alignment);
      }
      if (geometry_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Geometry);
      }
      if (center_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Center);
      }
      if (extent_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Extent);
      }
      if (HasClassificationSupported) {
        output.WriteRawTag(56);
        output.WriteBool(ClassificationSupported);
      }
      if (HasClassification) {
        output.WriteRawTag(64);
        output.WriteEnum((int) Classification);
      }
      if (HasClassificationStatus) {
        output.WriteRawTag(72);
        output.WriteEnum((int) ClassificationStatus);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasIdentifier) {
        output.WriteRawTag(10);
        output.WriteString(Identifier);
      }
      transform_.WriteTo(ref output, _repeated_transform_codec);
      if (HasAlignment) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Alignment);
      }
      if (geometry_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Geometry);
      }
      if (center_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Center);
      }
      if (extent_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Extent);
      }
      if (HasClassificationSupported) {
        output.WriteRawTag(56);
        output.WriteBool(ClassificationSupported);
      }
      if (HasClassification) {
        output.WriteRawTag(64);
        output.WriteEnum((int) Classification);
      }
      if (HasClassificationStatus) {
        output.WriteRawTag(72);
        output.WriteEnum((int) ClassificationStatus);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasIdentifier) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Identifier);
      }
      size += transform_.CalculateSize(_repeated_transform_codec);
      if (HasAlignment) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Alignment);
      }
      if (geometry_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Geometry);
      }
      if (center_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Center);
      }
      if (extent_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Extent);
      }
      if (HasClassificationSupported) {
        size += 1 + 1;
      }
      if (HasClassification) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Classification);
      }
      if (HasClassificationStatus) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ClassificationStatus);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ARPlaneAnchor other) {
      if (other == null) {
        return;
      }
      if (other.HasIdentifier) {
        Identifier = other.Identifier;
      }
      transform_.Add(other.transform_);
      if (other.HasAlignment) {
        Alignment = other.Alignment;
      }
      if (other.geometry_ != null) {
        if (geometry_ == null) {
          Geometry = new global::Mediapipe.ARPlaneGeometry();
        }
        Geometry.MergeFrom(other.Geometry);
      }
      if (other.center_ != null) {
        if (center_ == null) {
          Center = new global::Mediapipe.ARPlaneAnchor.Types.PlaneVector();
        }
        Center.MergeFrom(other.Center);
      }
      if (other.extent_ != null) {
        if (extent_ == null) {
          Extent = new global::Mediapipe.ARPlaneAnchor.Types.PlaneVector();
        }
        Extent.MergeFrom(other.Extent);
      }
      if (other.HasClassificationSupported) {
        ClassificationSupported = other.ClassificationSupported;
      }
      if (other.HasClassification) {
        Classification = other.Classification;
      }
      if (other.HasClassificationStatus) {
        ClassificationStatus = other.ClassificationStatus;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Identifier = input.ReadString();
            break;
          }
          case 18:
          case 21: {
            transform_.AddEntriesFrom(input, _repeated_transform_codec);
            break;
          }
          case 24: {
            Alignment = (global::Mediapipe.ARPlaneAnchor.Types.Alignment) input.ReadEnum();
            break;
          }
          case 34: {
            if (geometry_ == null) {
              Geometry = new global::Mediapipe.ARPlaneGeometry();
            }
            input.ReadMessage(Geometry);
            break;
          }
          case 42: {
            if (center_ == null) {
              Center = new global::Mediapipe.ARPlaneAnchor.Types.PlaneVector();
            }
            input.ReadMessage(Center);
            break;
          }
          case 50: {
            if (extent_ == null) {
              Extent = new global::Mediapipe.ARPlaneAnchor.Types.PlaneVector();
            }
            input.ReadMessage(Extent);
            break;
          }
          case 56: {
            ClassificationSupported = input.ReadBool();
            break;
          }
          case 64: {
            Classification = (global::Mediapipe.ARPlaneAnchor.Types.PlaneClassification) input.ReadEnum();
            break;
          }
          case 72: {
            ClassificationStatus = (global::Mediapipe.ARPlaneAnchor.Types.PlaneClassificationStatus) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Identifier = input.ReadString();
            break;
          }
          case 18:
          case 21: {
            transform_.AddEntriesFrom(ref input, _repeated_transform_codec);
            break;
          }
          case 24: {
            Alignment = (global::Mediapipe.ARPlaneAnchor.Types.Alignment) input.ReadEnum();
            break;
          }
          case 34: {
            if (geometry_ == null) {
              Geometry = new global::Mediapipe.ARPlaneGeometry();
            }
            input.ReadMessage(Geometry);
            break;
          }
          case 42: {
            if (center_ == null) {
              Center = new global::Mediapipe.ARPlaneAnchor.Types.PlaneVector();
            }
            input.ReadMessage(Center);
            break;
          }
          case 50: {
            if (extent_ == null) {
              Extent = new global::Mediapipe.ARPlaneAnchor.Types.PlaneVector();
            }
            input.ReadMessage(Extent);
            break;
          }
          case 56: {
            ClassificationSupported = input.ReadBool();
            break;
          }
          case 64: {
            Classification = (global::Mediapipe.ARPlaneAnchor.Types.PlaneClassification) input.ReadEnum();
            break;
          }
          case 72: {
            ClassificationStatus = (global::Mediapipe.ARPlaneAnchor.Types.PlaneClassificationStatus) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ARPlaneAnchor message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum Alignment {
        [pbr::OriginalName("UNDEFINED")] Undefined = 0,
        /// <summary>
        /// The plane is perpendicular to gravity.
        /// </summary>
        [pbr::OriginalName("HORIZONTAL")] Horizontal = 1,
        /// <summary>
        /// The plane is parallel to gravity.
        /// </summary>
        [pbr::OriginalName("VERTICAL")] Vertical = 2,
      }

      public enum PlaneClassification {
        [pbr::OriginalName("NONE")] None = 0,
        [pbr::OriginalName("WALL")] Wall = 1,
        [pbr::OriginalName("FLOOR")] Floor = 2,
        [pbr::OriginalName("CEILING")] Ceiling = 3,
        [pbr::OriginalName("TABLE")] Table = 4,
        [pbr::OriginalName("SEAT")] Seat = 5,
      }

      /// <summary>
      /// The classification status for the plane.
      /// </summary>
      public enum PlaneClassificationStatus {
        /// <summary>
        /// The classfication process for the plane anchor has completed but the
        /// result is inconclusive.
        /// </summary>
        [pbr::OriginalName("UNKNOWN")] Unknown = 0,
        /// <summary>
        /// No classication information can be provided (set on error or if the
        /// device does not support plane classification).
        /// </summary>
        [pbr::OriginalName("UNAVAILABLE")] Unavailable = 1,
        /// <summary>
        /// The classification process has not completed.
        /// </summary>
        [pbr::OriginalName("UNDETERMINED")] Undetermined = 2,
        /// <summary>
        /// The classfication process for the plane anchor has completed.
        /// </summary>
        [pbr::OriginalName("KNOWN")] Known = 3,
      }

      /// <summary>
      /// Wrapper for a 3D point / vector within the plane. See extent and center
      /// values for more information.
      /// </summary>
      public sealed partial class PlaneVector : pb::IMessage<PlaneVector>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<PlaneVector> _parser = new pb::MessageParser<PlaneVector>(() => new PlaneVector());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<PlaneVector> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.ARPlaneAnchor.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PlaneVector() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PlaneVector(PlaneVector other) : this() {
          _hasBits0 = other._hasBits0;
          x_ = other.x_;
          y_ = other.y_;
          z_ = other.z_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PlaneVector Clone() {
          return new PlaneVector(this);
        }

        /// <summary>Field number for the "x" field.</summary>
        public const int XFieldNumber = 1;
        private readonly static float XDefaultValue = 0F;

        private float x_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float X {
          get { if ((_hasBits0 & 1) != 0) { return x_; } else { return XDefaultValue; } }
          set {
            _hasBits0 |= 1;
            x_ = value;
          }
        }
        /// <summary>Gets whether the "x" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasX {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "x" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearX() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "y" field.</summary>
        public const int YFieldNumber = 2;
        private readonly static float YDefaultValue = 0F;

        private float y_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Y {
          get { if ((_hasBits0 & 2) != 0) { return y_; } else { return YDefaultValue; } }
          set {
            _hasBits0 |= 2;
            y_ = value;
          }
        }
        /// <summary>Gets whether the "y" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasY {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "y" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearY() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "z" field.</summary>
        public const int ZFieldNumber = 3;
        private readonly static float ZDefaultValue = 0F;

        private float z_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Z {
          get { if ((_hasBits0 & 4) != 0) { return z_; } else { return ZDefaultValue; } }
          set {
            _hasBits0 |= 4;
            z_ = value;
          }
        }
        /// <summary>Gets whether the "z" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasZ {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "z" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearZ() {
          _hasBits0 &= ~4;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as PlaneVector);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(PlaneVector other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(X, other.X)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Y, other.Y)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Z, other.Z)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasX) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(X);
          if (HasY) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Y);
          if (HasZ) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Z);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasX) {
            output.WriteRawTag(13);
            output.WriteFloat(X);
          }
          if (HasY) {
            output.WriteRawTag(21);
            output.WriteFloat(Y);
          }
          if (HasZ) {
            output.WriteRawTag(29);
            output.WriteFloat(Z);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasX) {
            output.WriteRawTag(13);
            output.WriteFloat(X);
          }
          if (HasY) {
            output.WriteRawTag(21);
            output.WriteFloat(Y);
          }
          if (HasZ) {
            output.WriteRawTag(29);
            output.WriteFloat(Z);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasX) {
            size += 1 + 4;
          }
          if (HasY) {
            size += 1 + 4;
          }
          if (HasZ) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(PlaneVector other) {
          if (other == null) {
            return;
          }
          if (other.HasX) {
            X = other.X;
          }
          if (other.HasY) {
            Y = other.Y;
          }
          if (other.HasZ) {
            Z = other.Z;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                X = input.ReadFloat();
                break;
              }
              case 21: {
                Y = input.ReadFloat();
                break;
              }
              case 29: {
                Z = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 13: {
                X = input.ReadFloat();
                break;
              }
              case 21: {
                Y = input.ReadFloat();
                break;
              }
              case 29: {
                Z = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// A collection of points in the world coordinate space.
  /// See https://developer.apple.com/documentation/arkit/arpointcloud for more
  /// information.
  /// </summary>
  public sealed partial class ARPointCloud : pb::IMessage<ARPointCloud>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ARPointCloud> _parser = new pb::MessageParser<ARPointCloud>(() => new ARPointCloud());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ARPointCloud> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.ARCaptureMetadataReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARPointCloud() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARPointCloud(ARPointCloud other) : this() {
      _hasBits0 = other._hasBits0;
      count_ = other.count_;
      point_ = other.point_.Clone();
      identifier_ = other.identifier_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARPointCloud Clone() {
      return new ARPointCloud(this);
    }

    /// <summary>Field number for the "count" field.</summary>
    public const int CountFieldNumber = 1;
    private readonly static int CountDefaultValue = 0;

    private int count_;
    /// <summary>
    /// The number of points in the cloud.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Count {
      get { if ((_hasBits0 & 1) != 0) { return count_; } else { return CountDefaultValue; } }
      set {
        _hasBits0 |= 1;
        count_ = value;
      }
    }
    /// <summary>Gets whether the "count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCount {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCount() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "point" field.</summary>
    public const int PointFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Mediapipe.ARPointCloud.Types.Point> _repeated_point_codec
        = pb::FieldCodec.ForMessage(18, global::Mediapipe.ARPointCloud.Types.Point.Parser);
    private readonly pbc::RepeatedField<global::Mediapipe.ARPointCloud.Types.Point> point_ = new pbc::RepeatedField<global::Mediapipe.ARPointCloud.Types.Point>();
    /// <summary>
    /// The list of detected points.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Mediapipe.ARPointCloud.Types.Point> Point {
      get { return point_; }
    }

    /// <summary>Field number for the "identifier" field.</summary>
    public const int IdentifierFieldNumber = 3;
    private static readonly pb::FieldCodec<long> _repeated_identifier_codec
        = pb::FieldCodec.ForInt64(26);
    private readonly pbc::RepeatedField<long> identifier_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// A list of unique identifiers corresponding to detected feature points.
    /// Each identifier in this list corresponds to the point at the same index
    /// in the points array.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<long> Identifier {
      get { return identifier_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ARPointCloud);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ARPointCloud other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Count != other.Count) return false;
      if(!point_.Equals(other.point_)) return false;
      if(!identifier_.Equals(other.identifier_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasCount) hash ^= Count.GetHashCode();
      hash ^= point_.GetHashCode();
      hash ^= identifier_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasCount) {
        output.WriteRawTag(8);
        output.WriteInt32(Count);
      }
      point_.WriteTo(output, _repeated_point_codec);
      identifier_.WriteTo(output, _repeated_identifier_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasCount) {
        output.WriteRawTag(8);
        output.WriteInt32(Count);
      }
      point_.WriteTo(ref output, _repeated_point_codec);
      identifier_.WriteTo(ref output, _repeated_identifier_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasCount) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Count);
      }
      size += point_.CalculateSize(_repeated_point_codec);
      size += identifier_.CalculateSize(_repeated_identifier_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ARPointCloud other) {
      if (other == null) {
        return;
      }
      if (other.HasCount) {
        Count = other.Count;
      }
      point_.Add(other.point_);
      identifier_.Add(other.identifier_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Count = input.ReadInt32();
            break;
          }
          case 18: {
            point_.AddEntriesFrom(input, _repeated_point_codec);
            break;
          }
          case 26:
          case 24: {
            identifier_.AddEntriesFrom(input, _repeated_identifier_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Count = input.ReadInt32();
            break;
          }
          case 18: {
            point_.AddEntriesFrom(ref input, _repeated_point_codec);
            break;
          }
          case 26:
          case 24: {
            identifier_.AddEntriesFrom(ref input, _repeated_identifier_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ARPointCloud message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public sealed partial class Point : pb::IMessage<Point>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Point> _parser = new pb::MessageParser<Point>(() => new Point());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Point> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.ARPointCloud.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Point() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Point(Point other) : this() {
          _hasBits0 = other._hasBits0;
          x_ = other.x_;
          y_ = other.y_;
          z_ = other.z_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Point Clone() {
          return new Point(this);
        }

        /// <summary>Field number for the "x" field.</summary>
        public const int XFieldNumber = 1;
        private readonly static float XDefaultValue = 0F;

        private float x_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float X {
          get { if ((_hasBits0 & 1) != 0) { return x_; } else { return XDefaultValue; } }
          set {
            _hasBits0 |= 1;
            x_ = value;
          }
        }
        /// <summary>Gets whether the "x" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasX {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "x" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearX() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "y" field.</summary>
        public const int YFieldNumber = 2;
        private readonly static float YDefaultValue = 0F;

        private float y_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Y {
          get { if ((_hasBits0 & 2) != 0) { return y_; } else { return YDefaultValue; } }
          set {
            _hasBits0 |= 2;
            y_ = value;
          }
        }
        /// <summary>Gets whether the "y" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasY {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "y" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearY() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "z" field.</summary>
        public const int ZFieldNumber = 3;
        private readonly static float ZDefaultValue = 0F;

        private float z_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Z {
          get { if ((_hasBits0 & 4) != 0) { return z_; } else { return ZDefaultValue; } }
          set {
            _hasBits0 |= 4;
            z_ = value;
          }
        }
        /// <summary>Gets whether the "z" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasZ {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "z" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearZ() {
          _hasBits0 &= ~4;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Point);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Point other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(X, other.X)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Y, other.Y)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Z, other.Z)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasX) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(X);
          if (HasY) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Y);
          if (HasZ) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Z);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasX) {
            output.WriteRawTag(13);
            output.WriteFloat(X);
          }
          if (HasY) {
            output.WriteRawTag(21);
            output.WriteFloat(Y);
          }
          if (HasZ) {
            output.WriteRawTag(29);
            output.WriteFloat(Z);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasX) {
            output.WriteRawTag(13);
            output.WriteFloat(X);
          }
          if (HasY) {
            output.WriteRawTag(21);
            output.WriteFloat(Y);
          }
          if (HasZ) {
            output.WriteRawTag(29);
            output.WriteFloat(Z);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasX) {
            size += 1 + 4;
          }
          if (HasY) {
            size += 1 + 4;
          }
          if (HasZ) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Point other) {
          if (other == null) {
            return;
          }
          if (other.HasX) {
            X = other.X;
          }
          if (other.HasY) {
            Y = other.Y;
          }
          if (other.HasZ) {
            Z = other.Z;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                X = input.ReadFloat();
                break;
              }
              case 21: {
                Y = input.ReadFloat();
                break;
              }
              case 29: {
                Z = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 13: {
                X = input.ReadFloat();
                break;
              }
              case 21: {
                Y = input.ReadFloat();
                break;
              }
              case 29: {
                Z = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Video image and face position tracking information.
  /// See developer.apple.com/documentation/arkit/arframe for more information.
  /// </summary>
  public sealed partial class ARFrame : pb::IMessage<ARFrame>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ARFrame> _parser = new pb::MessageParser<ARFrame>(() => new ARFrame());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ARFrame> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.ARCaptureMetadataReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARFrame() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARFrame(ARFrame other) : this() {
      _hasBits0 = other._hasBits0;
      timestamp_ = other.timestamp_;
      depthData_ = other.depthData_ != null ? other.depthData_.Clone() : null;
      depthDataTimestamp_ = other.depthDataTimestamp_;
      camera_ = other.camera_ != null ? other.camera_.Clone() : null;
      lightEstimate_ = other.lightEstimate_ != null ? other.lightEstimate_.Clone() : null;
      faceAnchor_ = other.faceAnchor_ != null ? other.faceAnchor_.Clone() : null;
      planeAnchor_ = other.planeAnchor_.Clone();
      rawFeaturePoints_ = other.rawFeaturePoints_ != null ? other.rawFeaturePoints_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ARFrame Clone() {
      return new ARFrame(this);
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 1;
    private readonly static double TimestampDefaultValue = 0D;

    private double timestamp_;
    /// <summary>
    /// The timestamp for the frame.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Timestamp {
      get { if ((_hasBits0 & 1) != 0) { return timestamp_; } else { return TimestampDefaultValue; } }
      set {
        _hasBits0 |= 1;
        timestamp_ = value;
      }
    }
    /// <summary>Gets whether the "timestamp" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTimestamp {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "timestamp" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTimestamp() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "depth_data" field.</summary>
    public const int DepthDataFieldNumber = 2;
    private global::Mediapipe.AVDepthData depthData_;
    /// <summary>
    /// The depth data associated with the frame. Not all frames have depth data.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.AVDepthData DepthData {
      get { return depthData_; }
      set {
        depthData_ = value;
      }
    }

    /// <summary>Field number for the "depth_data_timestamp" field.</summary>
    public const int DepthDataTimestampFieldNumber = 3;
    private readonly static double DepthDataTimestampDefaultValue = 0D;

    private double depthDataTimestamp_;
    /// <summary>
    /// The depth data object timestamp associated with the frame. May differ from
    /// the frame timestamp value. Is only set when the frame has depth_data.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double DepthDataTimestamp {
      get { if ((_hasBits0 & 2) != 0) { return depthDataTimestamp_; } else { return DepthDataTimestampDefaultValue; } }
      set {
        _hasBits0 |= 2;
        depthDataTimestamp_ = value;
      }
    }
    /// <summary>Gets whether the "depth_data_timestamp" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDepthDataTimestamp {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "depth_data_timestamp" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDepthDataTimestamp() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "camera" field.</summary>
    public const int CameraFieldNumber = 4;
    private global::Mediapipe.ARCamera camera_;
    /// <summary>
    /// Camera information associated with the frame.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ARCamera Camera {
      get { return camera_; }
      set {
        camera_ = value;
      }
    }

    /// <summary>Field number for the "light_estimate" field.</summary>
    public const int LightEstimateFieldNumber = 5;
    private global::Mediapipe.ARLightEstimate lightEstimate_;
    /// <summary>
    /// Light information associated with the frame.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ARLightEstimate LightEstimate {
      get { return lightEstimate_; }
      set {
        lightEstimate_ = value;
      }
    }

    /// <summary>Field number for the "face_anchor" field.</summary>
    public const int FaceAnchorFieldNumber = 6;
    private global::Mediapipe.ARFaceAnchor faceAnchor_;
    /// <summary>
    /// Face anchor information associated with the frame. Not all frames have an
    /// active face anchor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ARFaceAnchor FaceAnchor {
      get { return faceAnchor_; }
      set {
        faceAnchor_ = value;
      }
    }

    /// <summary>Field number for the "plane_anchor" field.</summary>
    public const int PlaneAnchorFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Mediapipe.ARPlaneAnchor> _repeated_planeAnchor_codec
        = pb::FieldCodec.ForMessage(58, global::Mediapipe.ARPlaneAnchor.Parser);
    private readonly pbc::RepeatedField<global::Mediapipe.ARPlaneAnchor> planeAnchor_ = new pbc::RepeatedField<global::Mediapipe.ARPlaneAnchor>();
    /// <summary>
    /// Plane anchors associated with the frame. Not all frames have a plane
    /// anchor. Plane anchors and face anchors are mutually exclusive.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Mediapipe.ARPlaneAnchor> PlaneAnchor {
      get { return planeAnchor_; }
    }

    /// <summary>Field number for the "raw_feature_points" field.</summary>
    public const int RawFeaturePointsFieldNumber = 8;
    private global::Mediapipe.ARPointCloud rawFeaturePoints_;
    /// <summary>
    /// The current intermediate results of the scene analysis used to perform
    /// world tracking.
    /// See
    /// https://developer.apple.com/documentation/arkit/arframe/2887449-rawfeaturepoints
    /// for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ARPointCloud RawFeaturePoints {
      get { return rawFeaturePoints_; }
      set {
        rawFeaturePoints_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ARFrame);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ARFrame other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Timestamp, other.Timestamp)) return false;
      if (!object.Equals(DepthData, other.DepthData)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(DepthDataTimestamp, other.DepthDataTimestamp)) return false;
      if (!object.Equals(Camera, other.Camera)) return false;
      if (!object.Equals(LightEstimate, other.LightEstimate)) return false;
      if (!object.Equals(FaceAnchor, other.FaceAnchor)) return false;
      if(!planeAnchor_.Equals(other.planeAnchor_)) return false;
      if (!object.Equals(RawFeaturePoints, other.RawFeaturePoints)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasTimestamp) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Timestamp);
      if (depthData_ != null) hash ^= DepthData.GetHashCode();
      if (HasDepthDataTimestamp) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(DepthDataTimestamp);
      if (camera_ != null) hash ^= Camera.GetHashCode();
      if (lightEstimate_ != null) hash ^= LightEstimate.GetHashCode();
      if (faceAnchor_ != null) hash ^= FaceAnchor.GetHashCode();
      hash ^= planeAnchor_.GetHashCode();
      if (rawFeaturePoints_ != null) hash ^= RawFeaturePoints.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasTimestamp) {
        output.WriteRawTag(9);
        output.WriteDouble(Timestamp);
      }
      if (depthData_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(DepthData);
      }
      if (HasDepthDataTimestamp) {
        output.WriteRawTag(25);
        output.WriteDouble(DepthDataTimestamp);
      }
      if (camera_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Camera);
      }
      if (lightEstimate_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(LightEstimate);
      }
      if (faceAnchor_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(FaceAnchor);
      }
      planeAnchor_.WriteTo(output, _repeated_planeAnchor_codec);
      if (rawFeaturePoints_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(RawFeaturePoints);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasTimestamp) {
        output.WriteRawTag(9);
        output.WriteDouble(Timestamp);
      }
      if (depthData_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(DepthData);
      }
      if (HasDepthDataTimestamp) {
        output.WriteRawTag(25);
        output.WriteDouble(DepthDataTimestamp);
      }
      if (camera_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Camera);
      }
      if (lightEstimate_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(LightEstimate);
      }
      if (faceAnchor_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(FaceAnchor);
      }
      planeAnchor_.WriteTo(ref output, _repeated_planeAnchor_codec);
      if (rawFeaturePoints_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(RawFeaturePoints);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasTimestamp) {
        size += 1 + 8;
      }
      if (depthData_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DepthData);
      }
      if (HasDepthDataTimestamp) {
        size += 1 + 8;
      }
      if (camera_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Camera);
      }
      if (lightEstimate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LightEstimate);
      }
      if (faceAnchor_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FaceAnchor);
      }
      size += planeAnchor_.CalculateSize(_repeated_planeAnchor_codec);
      if (rawFeaturePoints_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RawFeaturePoints);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ARFrame other) {
      if (other == null) {
        return;
      }
      if (other.HasTimestamp) {
        Timestamp = other.Timestamp;
      }
      if (other.depthData_ != null) {
        if (depthData_ == null) {
          DepthData = new global::Mediapipe.AVDepthData();
        }
        DepthData.MergeFrom(other.DepthData);
      }
      if (other.HasDepthDataTimestamp) {
        DepthDataTimestamp = other.DepthDataTimestamp;
      }
      if (other.camera_ != null) {
        if (camera_ == null) {
          Camera = new global::Mediapipe.ARCamera();
        }
        Camera.MergeFrom(other.Camera);
      }
      if (other.lightEstimate_ != null) {
        if (lightEstimate_ == null) {
          LightEstimate = new global::Mediapipe.ARLightEstimate();
        }
        LightEstimate.MergeFrom(other.LightEstimate);
      }
      if (other.faceAnchor_ != null) {
        if (faceAnchor_ == null) {
          FaceAnchor = new global::Mediapipe.ARFaceAnchor();
        }
        FaceAnchor.MergeFrom(other.FaceAnchor);
      }
      planeAnchor_.Add(other.planeAnchor_);
      if (other.rawFeaturePoints_ != null) {
        if (rawFeaturePoints_ == null) {
          RawFeaturePoints = new global::Mediapipe.ARPointCloud();
        }
        RawFeaturePoints.MergeFrom(other.RawFeaturePoints);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 9: {
            Timestamp = input.ReadDouble();
            break;
          }
          case 18: {
            if (depthData_ == null) {
              DepthData = new global::Mediapipe.AVDepthData();
            }
            input.ReadMessage(DepthData);
            break;
          }
          case 25: {
            DepthDataTimestamp = input.ReadDouble();
            break;
          }
          case 34: {
            if (camera_ == null) {
              Camera = new global::Mediapipe.ARCamera();
            }
            input.ReadMessage(Camera);
            break;
          }
          case 42: {
            if (lightEstimate_ == null) {
              LightEstimate = new global::Mediapipe.ARLightEstimate();
            }
            input.ReadMessage(LightEstimate);
            break;
          }
          case 50: {
            if (faceAnchor_ == null) {
              FaceAnchor = new global::Mediapipe.ARFaceAnchor();
            }
            input.ReadMessage(FaceAnchor);
            break;
          }
          case 58: {
            planeAnchor_.AddEntriesFrom(input, _repeated_planeAnchor_codec);
            break;
          }
          case 66: {
            if (rawFeaturePoints_ == null) {
              RawFeaturePoints = new global::Mediapipe.ARPointCloud();
            }
            input.ReadMessage(RawFeaturePoints);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 9: {
            Timestamp = input.ReadDouble();
            break;
          }
          case 18: {
            if (depthData_ == null) {
              DepthData = new global::Mediapipe.AVDepthData();
            }
            input.ReadMessage(DepthData);
            break;
          }
          case 25: {
            DepthDataTimestamp = input.ReadDouble();
            break;
          }
          case 34: {
            if (camera_ == null) {
              Camera = new global::Mediapipe.ARCamera();
            }
            input.ReadMessage(Camera);
            break;
          }
          case 42: {
            if (lightEstimate_ == null) {
              LightEstimate = new global::Mediapipe.ARLightEstimate();
            }
            input.ReadMessage(LightEstimate);
            break;
          }
          case 50: {
            if (faceAnchor_ == null) {
              FaceAnchor = new global::Mediapipe.ARFaceAnchor();
            }
            input.ReadMessage(FaceAnchor);
            break;
          }
          case 58: {
            planeAnchor_.AddEntriesFrom(ref input, _repeated_planeAnchor_codec);
            break;
          }
          case 66: {
            if (rawFeaturePoints_ == null) {
              RawFeaturePoints = new global::Mediapipe.ARPointCloud();
            }
            input.ReadMessage(RawFeaturePoints);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
